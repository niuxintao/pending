\section{Introduction}\label{sec:intro}

The behavior of modern software is affected by many factors, such as input parameters, configuration options, and specific events. To test such software system is challenging, as in theory we should test all the possible interaction of these factors to ensure the correctness of the System Under Test (SUT)\cite{song2012itree}. When the number of factors is large, the interactions to be checked increase exponentially, which makes exhaustive testing not feasible. Combinatorial testing (CT) is a promising solution to handle the combinatorial explosion problem \cite{kuhn2002investigation,kuhn2004software}. Instead of testing all the possible interactions in a system, it focuses on checking those interactions with number of involved factors no more than a prior number. Many studies in CT focus on designing a elaborate test suite (called covering array) to reveal such failures. Although covering array is effective and efficient as a test suite, it provides weak support to distinguish the failure-inducing interactions, i.e., Minimal Failure-causing schemas(MFS), from all the remaining interactions (schemas) \cite{colbourn2008locating,martinez2008algorithms}.


Consider the following example \cite{bach2004pairwise}, Table \ref{MS_word} presents a pair-wise covering array for testing an MS-Word application in which we want to examine various pair-wise interactions of options for `Highlight', `Status Bar', `Bookmarks' and `Smart tags'. Assume the last test case failed. We can get five pair-wise suspicious schemas that may be responsible for this failure. They are respectively (Highlight: Off, Status Bar: On), (Highlight: Off, Bookmarks: Off), (Highlight: Off, Smart tags: Off), (Status Bar: On, Bookmarks: Off), (Status Bar: On, Smart tags: Off),  and (Bookmarks: Off, Smart tags: Off). Without additional information, it is difficult to figure out the specific schemas in this suspicious set that caused the failure. In fact, considering that the schemas consist of other number of factors could also be MFS, e.g., (Highlight: Off) and (Highlight: Off, Status Bar: On, Smart tags: Off), the problem becomes more complicated. Generally, to definitely determine the MFS in a failing test case of \emph{n} factors, we need to check all the $2^n - 1$ interactions in this test case, which is not possible when \emph{n} is a large number.

\begin{table}
\caption{MS word example} \centering
  \label{MS_word}
  \setlength{\tabcolsep}{3pt}
  \begin{tabular}{c|cccc|c}\hline
id& \emph{Highlight} & \emph{Status bar} & \emph{Bookmarks}& \emph{Smart tags} & \bfseries{Outcome} \\\hline
1& On & On & On& On & PASS\\ \hline
2& Off & Off & On & On & PASS\\ \hline
3&On & Off & Off &On&  PASS\\ \hline
4&On & Off &On & Off&  PASS\\ \hline
5&Off&	On&	Off&Off & Fail\\ \hline
  \end{tabular}
\end{table}

To address this problem, prior work \cite{nie2011minimal} specifically studied the properties of MFS in SUT, based on which additional test cases were generated to identify them. Other approaches to identify the MFS in SUT include building a tree model \cite{yilmaz2006covering}, adaptively generating additional test cases according to the outcome of the last test case \cite{zhang2011characterizing}, ranking suspicious schemas based on some rules \cite{ghandehari2012identifying}, and using graphic-based deduction \cite{martinez2008algorithms}, among others. These approaches can be partitioned into two categories \cite{colbourn2008locating} according to how the additional test cases are generated: \emph{adaptive}--additional test cases are chosen based on the outcomes of the executed tests \cite{shi2005software,nie2011minimal,ghandehari2012identifying,niu2013identifying,zhang2011characterizing,shakya2012isolating,wang2010adaptive,li2012improved}or \emph{nonadaptive}--additional test cases are chosen independently and can be executed in parallel \cite{yilmaz2006covering,colbourn2008locating,martinez2008algorithms,martinez2009locating,zhang2012faulty}.

Although many efforts have been devoted to identify the failure-causing schemas from failing test cases, we argue that many of them are still incomplete in terms of the existence of schemas that cannot be determined to be faulty or not yet. Particularly, after identifying the MFS from one failing test case, we wonder that does the schemas other than the identified MFS are guaranteed to be irrelevant to the failure in this failing test case?  A related question is that, after identifying the MFS, is there exists any schema in this failing test case that is still cannot be determined to be faulty or not? To answer these two questions is important, because these cannot-be-determined schemas would be hidden dangers to the SUT. Moreover, we need the measures to evaluate the adequacy of the covering arrays and MFS identification approaches in CT, which is a important key to form the confidence of the developer of the SUT.  However, to our best knowledge, no such study has been proposed, especially from a theoretical view.

One simple solution is to exhaustively list all the schemas in one failing test case, and then check them to be faulty or not one by one. However, as we have mentioned before, the complexity of this procedure is $2^{n}$, where $n$ is the number of factors in this test case. Hence, this solution is far from feasible when $n$ is very large.

For all of these, a metric should be proposed to assist in evaluating the completeness of MFS identification approaches, and it should be more efficient than a simple exhaustive testing. In this paper, we proposed the notion of \textbf{pending schemas}, which indicates the schemas that cannot be determined to be faulty or not. By calculating the number of pending schemas in one failing test case, we can easily assess the extent to which the MFS identification approaches are incomplete. In fact, by the use of pending schemas, we can also evaluate the incompleteness of traditional covering arrays.

Furthermore, we theoretically analyzed the relationships among schemas by proposing nine novel propositions. Based on them, we gave three equivalent formulas, but with different complexities, to obtain the pending schemas. Among these formulas, Formula 3 helps to reduce the complexity of obtaining pending schemas from O($2^{n}$) to O($ \tau^{|FSS^{\bot}|+|HSS^{\top}|}$), where $\tau$ is the number of parameter values in the MFS, and $|FSS^{\bot}|$ and $|HSS^{\top}|$ are two relatively small numbers and independent on the number of parameters $n$ in one test case. Formula 3 is much more efficient at obtaining pending schemas when compared to the exhaustive methods which consecutively checks schemas in one failing test case, especially when $n$ is large.


We conducted a series empirical studies on some real software systems with various number of parameters and values. We first evaluated the incompleteness of traditional covering arrays and different fault localization approaches in CT. We also compared the efficiency of three formulas in terms of obtaining pending schemas. Our results mainly shows that the incompleteness in very common in the covering arrays and  MFS identification approaches. We also observed that Formula 3 is the most efficient formula among others in most cases.

\textbf{Contributions of this paper}:
\begin{itemize}

  \item We showed that the traditional covering arrays and the minimal failure-causing schema model are still incomplete in terms of the determination of schemas to be faulty or healthy.
  \item We introduced the notion of the pending schema to evaluate the incompleteness of these models in combinatorial testing.
  \item We proposed several propositions to formulate the set of pending schemas and gave three equivalent formulas to obtain the pending schemas, based on which we reduced the complexity of obtaining pending schemas from O($2^{n}$) to O($ \tau^{|FSS^{\bot}|+|HSS^{\top}|}$), where $|FSS^{\bot}|$ and $|HSS^{\top}|$ are two relatively small numbers and independent on the number of $n$.
  \item We conducted a series of experiments to evaluate the incompleteness of traditional covering arrays and MFS identification approaches. Besides, we also evaluated the efficiency of the three formulas on obtaining pending schemas.
\end{itemize}

The remainder of this paper is organized as follows: Section \ref{sec:motiv} describes the motivation for this work. Section \ref{sec:back} introduces some preliminary definitions and propositions. Section \ref{sec:pending} proposes several important propositions to formally define the determinable schemas and pending schemas. Section \ref{sec:pending:obtaining} formally identify the characteristics of the pending schemas and give a efficient formula to obtain it. Section \ref{sec:emp} evaluates the incompleteness of MFS identification approaches and compares the effectiveness of different approaches for obtaining pending schemas. Section \ref{sec:discussion} discusses the findings of our research works.  Section \ref{sec:related} summarizes the related works. Section \ref{sec:conclusion} concludes this paper and discusses the future works.


\section{Motivation}\label{sec:motiv}

In this section, we will use several examples to show the incompleteness of traditional covering arrays and well-known MFS identification approaches, respectively. These examples are derived from the MS-Word example listed in the introduction. For simplification, we use integer 0 to represent the state \emph{On} and 1 to represent the state \emph{Off} for each option. For example, the second test case listed in Table \ref{MS_word} can be denoted as (1, 1, 0, 0). Also, we use the intuitive notation (.., $v_{n_{i}}$ -, $v_{n_{k}}$, ..., -) to represent the schemas for the system, where $v_{n_{i}}$ indicate the value that is assigned to the corresponding factor and `-' indicates that the corresponding factor is not in this schema. For example, (1, 1, -, -) represents the schema (Highlight: Off, Status Bar: Off) in this example. Note that we will introduce a more formal denotation of test case and schema in the following section.


Also, to understand the following examples, we first give two rules. The first rule is that all the schemas in a passing test case are non-faulty, i.e., will not cause failure. The second rule is that any schema contain a MFS is a faulty schema, i.e., will also cause the failure. These two rules are wildly used in the MFS identification approaches \cite{nie2011minimal,zhang2011characterizing,ghandehari2012identifying,niu2013identifying}. We will discuss the justifications of these two rules later, as well as some issues if these two rules are not hold.

%first shows that with a normal $\tau$-way covering array, it is not completeness in terms of making  all the schemas clear for each failing test case.

%Then we give examples shows that even with fault localization, this is also not completeness (with three most important fault localization techniques.)

%give examples show based on two wide-used fault localization approaches in CT.

\subsection{The incompleteness of covering array}

We first consider the traditional covering arrays. To understand the incompleteness of the covering array, we need to check each schema in the test case of the covering array. As we said before, we use the same MS-Word example in the first section.  Figure \ref{fig_inc_ca} lists the detail of this example. The test cases $t_{1}$ to $t_{5}$ constitute the covering array shown in Table \ref{MS_word}. The complete set of the schemas of each test case is attached at the right side of the corresponding test case.  For example, for test case $t_{1}$, i.e., (0, 0, 0, 0), all the possible schemas (0, -, -, -), (0, 0, -, -), ..., are listed at the right side of $t_{1}$. There are $2^{4}-1 = 15$ schemas in total for each test case in this example.

\begin{figure*}[!ht]
 \centering
 \includegraphics[width=5.6in]{ca.eps}
 \caption{The incompleteness of Covering array }
 \label{fig_inc_ca}
\end{figure*}

In this figure, the test case with dark color represents a failing test case, while the test case with white color is a passing test case. The schema with white color is non-faulty, i.e., will not cause a failure, while the schema with dark color is faulty, i.e., any test case contain this schema would fail after testing. At last, the schema with light dark color and dashed outline is the pending schema, indicating that we cannot still determine whether it is faulty or non-faulty.

In this figure, we can first observe that all the schemas in the passing test case is non-faulty. This result is according to the first rule we mentioned before. The second observation is that the schema with the maximal number of factors (4 factors) in a failing test case is a faulty schema. In fact, this schema is the failing test case itself, i.e., (1, 1, 0, 1). This is because the failing test case must contain at least one MFS (otherwise, it will not fail). Hence, the schema which is the test case itself must also contain at least one MFS. As a result, it must be faulty schema according to the second rule we mentioned before. The last observation is that the other schemas in this failing test case $t_{5}$ are not guaranteed to be faulty schemas. In fact, if we assume this test case only contains one MFS (1, 1, 0, 1), then all the other schemas can be non-faulty schemas. Hence, these schemas cannot be determined to be faulty or not if we focus on this failing test case alone. As a result, we label these schemas as pending schemas initially.

Combining the three observations, we can further remove some pending schemas in $t_{5}$ by selecting the schemas that have already been appeared in the passing test cases. These schemas are (1, -, -, -), (-, -, 0, -), (-, 1, -, -), and (-, -, -, 0), which are labeled as non-faulty schemas. At last, the determination results of these schemas of $t_{5}$ can be shown in the ``\emph{Status}'' row. Note that except for these schemas that have been determined to be faulty and non-faulty, there still exist some pending schemas we cannot further removed by the original two rules. For example, (1, 0, -, -) didn't appear in any passing test case, and it did not contain any identified MFS. Hence, in this example, a single covering array is incomplete because of the existence of these pending schemas.

%because any schema can be the MFS in this test case. For example, if the test case itself as MFS, then no other schemas in this test case can be faulty schema.
%Initially. The schema with light dark color and dashed outline is the pending schema. These schemas cannot be determined by these two rules in the beginning. For example, schema (0, -, 1, -) is not appear in any passing test case, neither contain not any MFS.
%
%Initial is pending. Combining all the information, it is non-faulty.
%
%and the schema with
%
%In terms of making the failing test case clear. In this figure, which denoted what. what denoted what.

%\subsection{The incompleteness of error locating array}
%Since that , many approaches give a alleviation of how to compute the remaining schemas, which is called the fault localization. Error locating array is one of them. However, this time, we also give .

\subsection{The incompleteness of OFOT}
%SOFOT
Since covering array alone cannot remove all the pending schema in the failing test cases, we need more information to satisfy this target.  According to the second rule, i.e., the schema that contain the MFS is faulty schema, one method to reduce the number of pending schemas is to filter out those schemas which contain the MFS. However, without knowing the specific MFS in prior, we can only guarantee that the failing test case itself is faulty schema (it must contain the MFS). In fact, with the covering array alone, this is what we can only do to utilize the second rule.

Hence, to further reduce the set of pending schemas, we need to identify the MFS in the failing test case. One-Factor-One-Time (OFOT) \cite{nie2011minimal} is one of the most wildly used MFS identification approach. It identifies the MFS by modifying the original failing test case to see whether the modification would break the MFS in it. More specifically, at each time, it modifies one factor of the original failing test case and keeps the remaining factors to be as the same as the original failing test case. By doing this, it generates one new test case at each time. It then tests the newly generated test case. If this newly generated test case passes, it indicates the modified factor break the MFS in the original failing test case, and therefore, the original factor in the failing test case is one factor in the MFS. Otherwise, the original factor in the failing test case is not the factor in the MFS if the newly generated test case fails.
%Note that this conclusion is based on the newly generated MFS will not introduce new MFS, and hence, OFOT may not always obtain the accurate MFS.
%In fact, all the MFS identification approaches suffer from the need some assumptions to identify the MFS,

%which is also what we do in the covering arrays.
% For all we know is that the schemas as the failing test cases itself contain the MFS, others we do not know. Hence, it is important to identify the MFS to further narrow down the set of pending schemas.
Next, let us use OFOT to identify the MFS and help to narrow down the set of pending schemas of $t_{5}$ in the original covering array. First, we assume that there is one MFS (-, -, 1, 1) in failing test case $t_{5}$.  Then OFOT will work as follows: it generates four additional test cases $t_{6}$ to $t_{9}$ as shown in Figure \ref{fig_ofot_single}, respectively, each of which has one factor to be mutated from $t_{5}$.  Since $t_{8}$ and $t_{9}$ passed after testing, the original two factors (-, -, 1, -) and (-, -, -, 1) in $t_{5}$ are two factors in the MFS. The fails of $t_{6}$ and $t_{7}$ shows that there is no other factors in this MFS. Hence, OFOT identified the schema (-, -, 1, 1) as the MFS, which is identical to the schema (-, -, 1, 1) that we set as MFS in prior.

%MFS identification task is to distinguish. The wildly used approach is OFOT.
\begin{figure*}[ht]
 \centering
 \includegraphics[width=5.6in]{ofot_single.eps}
 \caption{OFOT with single MFS}
 \label{fig_ofot_single}
\end{figure*}

To analyse the pending schemas, we first list all the schemas in each additional test case in Figure \ref{fig_ofot_single}. The same as we observed from the covering array example, for the passing test case $t_{6}$ and $t_{7}$, all the schemas contained in it are non-faulty. For the failing test cases $t_{8}$ and $t_{9}$, we initially set the schemas which are failing test cases themselves as faulty schemas. Other schemas in these two failing test cases are all set to be pending schemas initially.

With these additional information, let us re-consider the status of the schemas in the original failing test case $t_{5}$. Firstly, as the identified MFS is (-, -, 1, 1), we can remove all the pending schemas of $t_{5}$ which contain this schema. These schemas are (-, -, 1, 1), (1, -, 1, 1), (-, 0, 1, 1), and (1, 0, 1, 1), respectively, and are labeled with dark color in the  ``\emph{Status}'' row for $t_{5}$ in Figure \ref{fig_ofot_single}. Next, we remove all the pending schemas of $t_{5}$ which appeared in these two passing test case $t_{6}$ and $t_{7}$. As shown in the  ``\emph{Status}'' row of Figure \ref{fig_ofot_single}, all the remaining pending schemas are removed and labeled with white color. Hence, we can learn that in this single MFS circumstance, OFOT works perfectly to remove all the pending schemas. However, when the failing test case contains multiple MFS, it does not go that well.

Now let us assume there are two MFS in the failing test case $t_{5}$, which are (1, 0, -, -) and (-, -, 1, 1), respectively. At this time, OFOT still generates the same four additional test cases, i.e., $t_{6}$ to $t_{9}$,  as shown in Figure \ref{fig_ofot_multi}. But different from the example of single MFS,  all the additional test cases failed at this time. This is because, the strategy of OFOT, i.e., mutating one factor at one time, cannot break all the MFS at the same time. As a result, it cannot identify any of the MFS.
%Why minimal failure-causing schema is not effective?
%This example shows that . Because there still existing pending schemas.
\begin{figure*}[ht]
 \centering
 \includegraphics[width=5.6in]{ofot_multi.eps}
 \caption{OFOT with multi MFS}
 \label{fig_ofot_multi}
\end{figure*}

There are two negative influences of this result. First, as we cannot identify the MFS by OFOT, the pending schemas in $t_{5}$ that contain the MFS also cannot be determined. Second, as all the test cases failed after testing, we cannot remove any pending schemas in $t_{5}$ that appear in the passing test case. As a result, the status of the pending schemas of $t_{5}$ will evolve to the ``\emph{Status}'' row of Figure \ref{fig_ofot_single}. We can observe that the status of the schemas of $t_{5}$ is the same as the previous example with only using covering array alone. Hence, in the condition that one failing test case contains multiple MFS, the MFS identification approach OFOT is still incomplete.


\subsection{The incompleteness of FIC}

From the example of OFOT, we can learn the main cause of incompleteness of OFOT is that the failing test case contains multiple MFS. For this, FIC \cite{zhang2011characterizing} (short for Faulty Interaction Characterization) augmented OFOT to handle the multiple MFS problem.
%It also mutates each factor in the original failing test case to generate additional test cases. But different from OFOT, which does not keep the value of the last mutation factor in the next test case generation (at each time, OFOT only mutates one factor and keep the remaining factors the same as the original failing test case), FIC may keep some changes in the next test case generation.  Specifically, when last generated test case failed after testing, FIC will keep the value of the changed factor to the next generations; Otherwise, if the last generated test case passed, FIC will not keep the value of the changed factor and assign the value of the original failing test case to this factor in the next generations. The reason for this is to  make FIC focus on only one MFS at each time and forbidden the appearance of other MFS.
FIC also mutates one factor at a time to generate one additional test case.  The only difference is that it will not always rollback to the original value of one factor it has mutated when it goes on mutating other factors (only when a passing test case appears, it will rollback to the original value). This operation will break multiple MFS in one test case and finally there remains only one MFS to identify. We still use the same example of multiple MFS used in OFOT to illustrate how FIC works and to see whether FIC satisfies the completeness criteria. The result is shown in Figure \ref{fig_fic_multi}.

\begin{figure*}[!htb]
 \centering
 \includegraphics[width=5.3in]{fic.eps}
 \caption{FIC with multiple MFS}
 \label{fig_fic_multi}
\end{figure*}

In Figure \ref{fig_fic_multi}, FIC also generated four additional test cases $t_{6}$ to $t_{9}$. The first case $t_{6}$ is the same as the $t_{6}$ generated by OFOT, but the second additional test case $t_{7}$ generated by FIC is different from $t_{7}$ generated by OFOT. This is because $t_{7}$ generated by FIC keeps the first value of $t_{6}$ (which is a failing test case) instead of the original first value of $t_{5}$. Note that FIC also keeps this value in the following generated test cases $t_{8}$ and $t_{9}$. By doing this, FIC forbids the appearance of the MFS (1, 0, -, -) later. The same as the first value of $t_{6}$, $t_{8}$ and $t_{9}$ keep the second value of $t_{7}$ because $t_{7}$ is also a failing test case. The failings of $t_{6}$ and $t_{7}$ indicated that there still exists other MFS in the original failing test case $t_{5}$, while the first and second factor is not in the remaining MFS.

With respect to the passing test case $t_{8}$, test case $t_{9}$ did not keep the third value of $t_{8}$ but rollback to the value of the original failing test case $t_{5}$. This is because, since $t_{8}$ passed after testing, there is no MFS in this test case. FIC should rollback this value to keep this factor of the MFS and check if there exists other factor of this MFS or not. After all, the passings of $t_{8}$ and $t_{9}$ indicated that (-, -, 1, -) and (-, -, -, 1) are two the factors in the remaining MFS. Hence, the MFS identified by FIC is (-, -, 1, 1).

Next, let us check status of the original failing test case $t_{5}$. The same as OFOT, we first remove the pending schemas that contain the MFS (-, -, 1, 1), and then remove the pending schemas that appear in the additional passing test case. The result is listed in the ``\emph{Status}'' row of Figure \ref{fig_fic_multi}. We can observe that there still exists 6 pending schemas, i.e., (1, 0, -, -), (1, -, 1, -), (1, -, -, 1), (1, 0, 1, -), (1, 0, -, 1), (-, 0, 1, -), and (-, 0, -, 1), respectively.

One reason for this incompleteness that FIC missed anther MFS in the failing test case $t_{5}$, which is (1, 0, -, -). The iterative version of FIC \cite{zhang2011characterizing}, i.e., FINOLP is designed to handle this problem. Specifically, after identifying one MFS in the original failing test case,  FINOLP first generates one more test case by mutating the factors in the original failing test case which appear in the identified MFS. If the generated test case fails after testing, which indicates that there still exists other MFS, it will use FIC to identify the MFS in this generated test case. This process repeats until the test case which is generated by mutating all the factors in the identified MFS passes. Figure \ref{fig_finovlp_multi} shows the detail when applying FINOLP on this example.
%The incompleteness of Finovlp

\begin{figure*}[!htb]
 \centering
 \includegraphics[width=5.3in]{finovlp.eps}
 \caption{FINOVLP with multiple MFS}
 \label{fig_finovlp_multi}
\end{figure*}

In Figure \ref{fig_finovlp_multi}, test cases $t_{1}$ to $t_{9}$ are the same as those of the example in Figure \ref{fig_fic_multi}.  After identifying the MFS (-, -, 1, 1), FINOLP first generated the test case $t_{10}$ to check whether there exists other MFS in the original failing test case $t_{5}$ by mutating the values that appear in this MFS. Since $t_{10}$ failed after testing, it repeated FIC approach on $t_{10}$ to identified the remaining MFS. Therefore, it generated four additional test cases $t_{11}$ to $t_{14}$. The passings of $t_{11}$ and $t_{12}$ indicated another MFS was (1, 0, -, -). FINOLP continued to check whether there exists any other MFS by generating the test case $t_{15}$. The passing of $t_{15}$ showed that there did not exist any other MFS in the original failing test case $t_{5}$. Above all, FINOLP accurately identified all the MFS we have set in piror.

Next, the same as before, we use the two rules to check the status of the pending schemas in the original failing test case $t_{5}$. The result is shown in the ``\emph{Status}'' row of Figure \ref{fig_finovlp_multi}. We can observe that there still exists four schemas, which are (1, -, 1, -), (1, -, -, 1), (-, 0, 1, -), and (-, 0, -, 1), respectively. It is easy to find that these four schemas neither contain any MFS nor appears in any passing test cases. Hence, although FIC and FINOLP can handle the multiple MFS problem, it is still incomplete for the existence of these pending schemas.

\subsection{Additional efforts to remove the pending schemas}

Since Covering array, OFOT, FIC, and FINOLP cannot remove all the pending schemas, more efforts are needed to accomplish this goal. Note that to clear all the pending schemas is important, because some of them can be potential faulty schemas and may be harmful for this system under testing. For this, we decided to check these remaining pending schemas by generating more test cases that contained them and executing these test cases. If these test cases passes, we can directly use the first rule we mentioned before to determine these schemas to be non-faulty schemas. Otherwise, we need to adopt other methods to determine these schemas to be faulty or not.

\begin{figure*}[!htb]
 \centering
 \includegraphics[width=5.3in]{non-pending.eps}
 \caption{Additional efforts to remove pending schemas}
 \label{fig_no_pending}
\end{figure*}

As for this example, we generated four test cases to contain these pending schemas one by one (Note that in this example, we cannot generate one test case contain more than one pending schema without including any MFS). The result is shown in Figure \ref{fig_no_pending}. In this figure, all the additional test cases, i.e., $t_{16}$ to $t_{19}$, passed after testing. Hence, all the remaining schemas are non-faulty schemas. The final status of the pending schemas of $t_{5}$ is shown in the ``\emph{Status}'' row of Figure \ref{fig_no_pending}. We can observe that all the schemas in $t_{5}$ are determined to be non-faulty or faulty. Hence, in this condition, we can guarantee that the test of $t_{5}$ is complete.

Note that if any of the test case ($t_{16}$ to $t_{19}$) failed after testing, we cannot determine whether the corresponding pending schema in that test case is faulty or not.  In this case, we need to generate more test cases to determine the status of this pending schema (If this schema is a faulty schema, the cost will increase exponentially according to the formal definition of faulty schema which will be given later).

\subsection{A summary}

There are two main observations from this section. First, traditional covering array and MFS identification approaches are still incomplete in terms of the existence of pending schemas which cannot be determined to faulty or non-faulty. Second, to remove all the pending schemas is time-consuming. In fact, just listing all the schemas and checking them one by one is inefficient. In this example, we need to check $2^{4} - 1 = 5$ schemas for each test case. However, with the increase of the number of factors in one test case, the cost for checking the pending schemas increase exponentially.

For all of these, we need to theoretically analyze the properties of the pending schemas in the failing test cases and to give a more efficient method to obtain them.
%It needs a formal definition and theoretical analysis for the pending schemas with non-faulty schemas and faulty schemas.

\section{Background}\label{sec:back}
This section presents some definitions and propositions to give a formal model for CT.
%\subsection{Failure-inducing interactions in CT}
Without loss of generality, assume that the Software Under Test (SUT) is influenced by a set of parameters $P$, which contains \emph{n} parameters, and each parameter $p_{i} \in P$ can take the values from the finite set $V_{i}$ ($i$ = 1,2,..n).

\newtheorem{assumption}{Assumption}

\subsection{Test cases and schemas}\label{sec:back:testandschema}
In this subsection, we will formally define the test case and schema. We will also give the properties to reveal the relationships between them. In these propositions, Proposition   are originated from our previous work .
 %Moreover, we will use the same SUT in the motivation (the MS-WORD example that has four factors may influnence  ) to show the definitions and propositions.

\begin{definition}\label{de:testcase}
A \emph{test case} of the SUT is a tuple of \emph{n} values, one for each parameter of the SUT. It is denoted as  ($v_{1}$, $v_{2}$,...,$v_{n}$), where $v_{1}\in V_{1}$, $v_{2} \in V_{2}$ ... $v_{n} \in V_{n}$.
\end{definition}

In practice, these parameters in the test case can represent many factors, such as input variables, run-time options, building options or various combination of them. We need to execute the SUT with these test cases to ensure the correctness of the behaviour of the SUT.

\begin{definition}\label{de:schema}
For the SUT, the $\tau$-set \{$(p_{x_{1}}, v_{x_{1}})$, $(p_{x_{2}}, v_{x_{2}})$, ..., $(p_{x_{\tau}}, v_{x_{\tau}})$\}, where $0 \leq x_{i} \leq n$, $p_{x_{i}} \in P$, and $v_{x_{i}} \in V_{x_{i}}$, is called a $\tau$-degree \emph{schema} ($0 < \tau \leq n $), when a set of $\tau$ values assigned to $\tau$ distinct parameters.
\end{definition}

For example, the interactions (Highlight: Off, Status Bar: On, Smart tags: Off) appearing in Section \ref{sec:intro} is a 3-degree schema, where three parameters are assigned to corresponding values. In effect a test case itself is a n-degree \emph{schema}, which can be described as \{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, ..., $(p_{n}, v_{n})$\}. Also, for any schema, say, $s$, its degree can be denoted as $|s|$ because a schema is essentially  a set of parameter values.

Note that this definition of schema is a formal description of schemas we discussed in the section of \emph{Motivation}. For example, the schema (1, -, 0, -) is exactly the schema \{ $(p_{1}, 1)$, $(p_{3}, 0)$ \} here. We use this formal definition because it benefits the description of the following theoretical analysis, including these propositions and proofs.

\begin{definition}\label{de:subsume}
Let $s_{1}$, $s_{2}$ be two schemas in SUT. If $\forall (p_{x_{1}}, v_{x_{1}}) \in s_{1}$, $(p_{x_{1}}, v_{x_{1}}) \in s_{2}$, then $s_{1}$ is the $sub-schema$ of $s_{2}$, and $s_{2}$ the $super-schema$ of $s_{1}$, which can be denoted as $s_{1} \preceq s_{2}$. Further, if $|s_{1}| < |s_{2}|$, we call $s_{1}$ the $real-sub-schema$ of $s_{2}$, which is denoted as $s_{1} \prec s_{2}$.
\end{definition}

For example,  the 2-degree schema \{($p_{1}, 1$), ($p_{2}, 0$)\} is a sub-schema (also is a real-sub-schema) of the 3-degree schema \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{4}, 1$)\}.
%Also, since a test case itself is a schema, then if a test case $t$ contains a schema $s$, we have $s \preceq t$. For example,  the 2-degree schema \{($p_{1}, 1$), ($p_{2}, 0$)\} is also a sub-schema of a test case \{($p_{1}, 1$), ($p_{2}, 0$), ( Bookmarks, On), ($p_{4}, 1$)\}.

According to the definition of schemas, it is easy to find the following three properties of schemas.

\begin{proposition}[Reflexivity]\label{pro:subsumereflexivity}
For any schema $s$, $s \preceq s$.
\end{proposition}

\begin{proof}
Since $\forall (p_{x_{i}}, v_{x_{i}})\in s$, $(p_{x_{i}}, v_{x_{i}}) \in s$. Hence, $s \preceq s$ according to the definition of \ref{de:subsume}.
\end{proof}

This proposition tells that any schema is the subschema of itself. For example the 2-degree schema \{($p_{1}, 1$), ($p_{2}, 0$)\} is a sub-schema of itself  \{($p_{1}, 1$), ($p_{2}, 0$)\}.

\begin{proposition}[Antisymmetry]\label{pro:subsumeantisymmetry}
For schemas $s_{1}$, $s_{2}$, if $s_{1} \preceq s_{2}$ and $s_{2} \preceq  s_{1}$, then $s_{1}$ = $s_{2}$.
\end{proposition}

\begin{proof}
As $s_{1} \preceq s_{2}$, then $\forall (p_{x_{i}}, v_{x_{i}})\in s_{1}, (p_{x_{i}}, v_{x_{i}}) \in s_{2}$. This indicates that the parameter value set $s_{1}$ is the subset of  $s_{2}$, i.e., $s_{1} \subseteq s_{2}$.  Also as $s_{2} \preceq s_{1}$, $s_{2} \subseteq s_{1}$. Since, $s_{1} \subseteq s_{2}$ and $s_{2} \subseteq s_{1}$, we have the two parameter value sets $s_{1}$ and $s_{2}$ are equal, i.e., $s_{1}$ = $s_{2}$.
\end{proof}

This proposition shows that for two distinct schemas, one cannot be both super-schema and sub-schema of the other schema. For example, the 2-degree schema \{($p_{1}, 1$), ($p_{2}, 0$)\} is a sub-schema of the 3-degree schema \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{4}, 1$)\}, but not a super-schema of this 3-degree schema.  Only two equal schemas can be both the sub-schema and super-schema of each other. For example, the 2-degree schema \{($p_{1}, 1$), ($p_{2}, 0$)\} is both the sub-schema and super-schema of itself.
%related in both directions.

\begin{proposition}[Transitive]\label{pro:subsumetrans}
Given schemas $s_{1}$, $s_{2}$, and $s_{3}$, if $s_{1} \preceq s_{2}$, $s_{2} \preceq s_{3}$, then $s_{1} \preceq s_{3}$.
\end{proposition}

\begin{proof}
As $s_{1} \preceq s_{2}$, then $\forall (p_{x_{i}}, v_{x_{i}})\in s_{1}, (p_{x_{i}}, v_{x_{i}}) \in s_{2}$. Also, $s_{2} \preceq s_{3}$, then $\forall (p_{x_{i}}, v_{x_{i}})\in s_{2}, (p_{x_{i}}, v_{x_{i}}) \in s_{3}$. Hence, $\forall (p_{x_{i}}, v_{x_{i}})\in s_{1}, (p_{x_{i}}, v_{x_{i}}) \in s_{3}$. According to definition \ref{de:subsume}, $s_{1} \preceq s_{3}$.
\end{proof}

This proposition shows the transitivity of the subsuming relationships of schemas. For example, the 1-degree schema \{($p_{1}, 1$)\} is a sub-schema of the 2-degree schema \{($p_{1}, 1$), ($p_{2}, 0$)\}, and this 2-degree schema is a sub-schema of the 3-degree schema \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{4}, 1$)\}. Therefore, the 1-degree schema \{($p_{1}, 1$)\} is also a sub-schema of the 3-degree schema \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{4}, 1$)\}.


These three propositions together show that the schema set $(s, \preceq)$ is a partial order set. Next, we will introduce the relationships between schemas and tests.

\begin{definition}\label{de:containorhit}
For a schema $s$, if there exists one test case $t$, such that each parameter value in the schema $s$ is also in the test case $t$, i.e., $\forall (p_{x_{i}}, v_{x_{i}}) \in s, (p_{x_{i}}, v_{x_{i}}) \in t$, then we call the test case $t$ \emph{hits} or \emph{contains} the schema $s$, and test case $t$ is one \emph{container} of schema $s$.
\end{definition}

Note that test case is also a $n$-degree schema, hence when a test case $t$ hits one schema $s$, we can denote this relationship simply as $s \preceq t, |t| = n$. As an example, test case \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 1$), ($p_{4}, 0$)\} hits the 2-degree schema \{($p_{1}, 1$), ($p_{2}, 0$)\}.

\begin{definition} \label{de:alltests}
 For a schema $s$, the set of all the possible containers of it, i.e., the set of all the possible test cases that contain this schema, is called the \emph{whole set} of containers of this schema $s$, which is denoted as $\mathcal{T}(s)$.
\end{definition}

Formally, $\mathcal{T}(s) = \{ t | s \preceq t, |t| = n\}$. As an example, let us consider the SUT that has four parameters and each parameter has two values (All the following examples are based on the same SUT). Let schema $s$ be \{($p_{1}, 1$), ($p_{2}, 0$)\}. Table \ref{ex:wholecontainer} shows $\mathcal{T}(s)$.  It can be observed that each possible test case in the SUT that contains schema $s$ is listed in Table \ref{ex:wholecontainer}.
 %are the set of four test cases \{ \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\}, \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} ,  \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 1$), ($p_{4}, 0$)\}, \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 1$), ($p_{4}, 1$)\}  \}.


\begin{table}[htbp]
  \centering
  \caption{Whole set of containers of \{($p_{1}, 1$), ($p_{2}, 0$)\}}
   % {\footnotesize
  \label{ex:wholecontainer}
    \begin{tabular}{|c|c|}\hline
  \multicolumn{2}{|c|}{ \textbf{Schema}} \\ \hline
   $s$ & \{($p_{1}, 1$), ($p_{2}, 0$)\} \\ \hline
  \multicolumn{2}{|c|}{ \textbf{ $\mathcal{T}(s)$ }}\\ \hline
    $t_{1}$ &   \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\
    $t_{2}$ &   \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} \\
    $t_{3}$ &   \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 1$), ($p_{4}, 0$)\} \\
    $t_{4}$ &   \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 1$), ($p_{4}, 1$)\} \\ \hline
    \end{tabular}
   % }
\end{table}%



With respect the the whole set of containers of one schema, we have the following property.

\begin{proposition}[{smaller schema has a larger $\mathcal{T}(s)$}] \label{pro:shl}
For schemas $s_{1}$ and $s_{2}$, if $s_{1} \preceq s_{2}$, then $\mathcal{T}(s_{2}) \subseteq \mathcal{T}(s_{1})$.
\end{proposition}

\begin{proof}
$\forall t \in \mathcal{T}(s_{2})$, $s_{2} \preceq t$. Since $s_{1} \preceq s_{2}$, we have $s_{1} \preceq t$ according to Proposition \ref{pro:subsumetrans}. That is, $t$ contains $s_{1}$. Therefore, $t \in \mathcal{T}(s_{1})$.  Hence,  $\mathcal{T}(s_{2}) \subseteq \mathcal{T}(s_{1})$.
\end{proof}

% Table generated by Excel2LaTeX from sheet 'T(s)'
As an example, let schema $s_{1}$ be \{($p_{1}, 1$), ($p_{2}, 0$)\}, and schema $s_{2}$ be \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$)\}, which is one of the super-schemas of $s_{1}$. Table \ref{ex:smallerschemahaslarger} shows the whose set of containers of  $s_{1}$ and $s_{2}$. We can observe that $\mathcal{T}(s_{1})$ subsumes  $\mathcal{T}(s_{2})$.

\begin{table}[htbp]
  \centering
  \caption{Comparison of the whole set of containers of two subsuming schemas}
 %   {\footnotesize
      \label{ex:smallerschemahaslarger}
    \begin{tabular}{|c|c|} \hline
   \multicolumn{2}{|c|}{\textbf{Schema}} \\ \hline
   $s_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$)\} \\ \hline
   \multicolumn{2}{|c|}{\textbf{ $\mathcal{T}(s_{1})$ }}\\ \hline
   $t_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\
   $t_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} \\
   $t_{3}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 1$), ($p_{4}, 0$)\} \\
   $t_{4}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 1$), ($p_{4}, 1$)\} \\ \hline\hline
   \multicolumn{2}{|c|}{ \textbf{ Schema}} \\ \hline
   $s_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$)\} \\ \hline
   \multicolumn{2}{|c|}{\textbf{ $\mathcal{T}(s_{2})$ }}\\ \hline
   $t_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\
   $t_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} \\ \hline
    \end{tabular}%
   % }
\end{table}%



\begin{definition} \label{de:allschemas}
For a test case $t$, all the schemas that it can hit is called the \emph{whole set} of hit schemas of $t$, which is denoted as $\mathcal{I}(t)$.
\end{definition}

Formally,$\mathcal{I}(t) = \{ s | s \preceq t \}$. As an example, let test case $t$ be  \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\}. Table \ref{ex:wholesetofhitschemas} shows $\mathcal{I}$ ($t$). We can find it is a set of $2^{4} - 1 = 15$ schemas.

\begin{table}[htbp]
  \centering
  \caption{An example of whole set of hit schemas of one test case}
 %   {\footnotesize
      \label{ex:wholesetofhitschemas}
    \begin{tabular}{|c|c|} \hline
   \multicolumn{2}{|c|}{\textbf{Test Case}} \\ \hline
   $t$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\ \hline
    \multicolumn{2}{|c|}{\textbf{ $\mathcal{I}(t)$ }}\\ \hline
   $s_{1}$ & \{($p_{1}, 1$)\} \\
   $s_{2}$ & \{($p_{2}, 0$)\} \\
   $s_{3}$ & \{($p_{3}, 0$)\} \\
   $s_{4}$ & \{($p_{4}, 0$)\} \\
   $s_{5}$ & \{($p_{1}, 1$),($p_{2}, 0$)\} \\
   $s_{6}$ & \{($p_{1}, 1$),($p_{3}, 0$)\} \\
   $s_{7}$ & \{($p_{1}, 1$),($p_{4}, 0$)\} \\
   $s_{8}$ & \{($p_{2}, 0$),($p_{3}, 0$)\} \\
   $s_{9}$ & \{($p_{2}, 0$),($p_{4}, 0$)\} \\
   $s_{10}$ & \{($p_{3}, 0$),($p_{4}, 0$)\} \\
   $s_{11}$ & \{($p_{1}, 1$),($p_{2}, 0$),($p_{3}, 0$)\} \\
   $s_{12}$ & \{($p_{1}, 1$),($p_{2}, 0$),($p_{4}, 0$)\} \\
   $s_{13}$ & \{($p_{1}, 1$),($p_{3}, 0$),($p_{4}, 0$)\} \\
   $s_{14}$ & \{($p_{2}, 0$),($p_{3}, 0$),($p_{4}, 0$)\} \\
   $s_{15}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\ \hline
    \end{tabular}%
   % }
\end{table}%


\begin{definition} \label{de:allschemasoft}
For a set of test case $T$, all the schemas that these test cases can hit is called the \emph{whole set} of hit schemas of $T$, which is denoted as $\mathcal{I}(T)$.
\end{definition}

$\mathcal{I}(T)$ extends $\mathcal{I}(t)$ to a set of test cases. Formally, $\mathcal{I}(T) = \bigcup_{t \in T} \mathcal{I}(t)$.


\begin{definition} \label{de:specialschema}
All the schemas that are \textbf{only} contained in test set $T$ is called the \emph{special schemas} of test case set $T$, which is denoted as  $\mathcal{S}(T)$.
\end{definition}

Formally, $\mathcal{S}(T) =  \mathcal{I}(T) \backslash \mathcal{I}(\bar{T}) $, where $\bar{T}$ is the complementary test set of $T$, i.e., $T \bigcup \bar{T} = T^{*}, T \bigcup \bar{T} = \emptyset$. Here, $T^{*}$ indicates all the possible test cases in the SUT. Based on this formula, we can learn that the special schemas are essentially the whole set of hit schemas of test case $T$, except for those hit schemas of other test cases.

As an example, let test case $t_{1}$ be \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} and $t_{2}$ be \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\}. Let the test case set $T$ be \{ $t_{1}$ , $t_{2}$ \}. Table \ref{ex:specialschemasoftestset} shows the schemas of $\mathcal{S}(T)$. We can observe that there are only three schemas $s_{1}$, $s_{2}$, and $s_{3}$ in this schema set. Other hit schemas of $T$ that can appear in other test cases do not belong to $\mathcal{S}(T)$. For example, schema \{($p_{1}, 1$), ($p_{2}, 0$)\} can appear in the test case \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 1$), ($p_{4}, 1$)\}, which is not in $T$. Hence, \{($p_{1}, 1$), ($p_{2}, 0$)\} is only one hit schema of $T$, but not the special schema of $T$.

\begin{table}[htbp]
  \centering
  \caption{An example of special schemas of test case set}
 %   {\footnotesize
      \label{ex:specialschemasoftestset}
    \begin{tabular}{|c|c|} \hline
  \multicolumn{2}{|c|}{\textbf{Test Case set $T$}} \\ \hline
  $t_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\}\\
  $t_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\}\\ \hline
  \multicolumn{2}{|c|}{\textbf{ $\mathcal{S}(T)$ }}  \\ \hline
  $s_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$)\}  \\
  $s_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\
  $s_{3}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} \\ \hline
    \end{tabular}%
   % }
\end{table}%


With respect to the special schema set of test case $T$, we can obtain the following property.

\begin{proposition}[Whole container of special schema set]\label{pro:stct}
For any test set $T$ of the SUT,  $\bigcup_{s \in \mathcal{S}(T)}\mathcal{T}(s) = T$.
\end{proposition}
\begin{proof}
As $\mathcal{S}(T) =  \mathcal{I}(T) \backslash \mathcal{I}(\bar{T}) $,  $\forall s \in \mathcal{S}(T),\ s \in \mathcal{I}(T)\ and\ s \not\in \mathcal{I}(\bar{T})$. Then $\forall t \in \mathcal{T}(s), t \ contains\ s$, indicating that $t \in T$.  Hence, $\mathcal{T}(s) \subseteq T$.  Then $\bigcup_{s \in \mathcal{S}(T)}\mathcal{T}(s) \subseteq T$.

On the other hand, $\forall t \in T$,  $\exists s' \in \mathcal{I}(t)$, such that $s' \not\in \mathcal{I}(\bar{T})$ (at least it holds when $s' = t$). Hence, $s' \in \mathcal{S}(T)$.  Obviously $t \in \mathcal{T}(s') \subseteq \bigcup_{s \in \mathcal{S}(T)} \mathcal{T}(s)$. Therefore,  $ T \subseteq \bigcup_{s \in \mathcal{S}(T)}\mathcal{T}(s)$.

Since $\bigcup_{s \in \mathcal{S}(T)}\mathcal{T}(s) \subseteq T$ and $T \subseteq \bigcup_{s \in \mathcal{S}(T)}\mathcal{T}(s)$, we have $\bigcup_{s \in \mathcal{S}(T)}\mathcal{T}(s) =  T$.
\end{proof}


Proposition \ref{pro:stct} revels the relationship between test case set and its special schemas. That is, for a specific test set, the whole set of containers of its special schemas are equal to this original test set. As an example,
 let test case $t_{1}$, $t_{2}$  still be \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\}, \{($p_{1}, 1$), and ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\}, respectively. Let the test case set $T$ be \{ $t_{1}$ , $t_{2}$\}.  Table \ref{ex:prospecialschemasoftestset} specifically shows the whole containers for each special schema for test case set $T$, as well as their union. We can observe that their union, i.e.,  $\bigcup_{s \in \mathcal{S}(T)}\mathcal{T}(s)$ is equal to the original test set $T$.

\begin{table}[htbp]
  \centering
  \caption{An example of the whole set of containers of special schemas}
 %   {\footnotesize
      \label{ex:prospecialschemasoftestset}
    \begin{tabular}{|c|c|} \hline
  \multicolumn{2}{|c|}{\textbf{Test Case set}} \\ \hline
  $t_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\}\\
  $t_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\}\\ \hline
  \multicolumn{2}{|c|}{\textbf{ $\mathcal{S}(T)$ }}  \\ \hline
  $s_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$)\}  \\
  $s_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\
  $s_{3}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} \\ \hline
   \multicolumn{2}{|c|}{\textbf{ $\mathcal{T}(s_{1})$}}  \\ \hline
  $t_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\
  $t_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} \\ \hline
      \multicolumn{2}{|c|}{\textbf{ $\mathcal{T}(s_{2})$}}  \\ \hline
  $t_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\ \hline
      \multicolumn{2}{|c|}{\textbf{ $\mathcal{T}(s_{3})$}}  \\ \hline
  $t_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} \\ \hline
    \multicolumn{2}{|c|}{\textbf{  $\bigcup_{s \in \mathcal{S}(T)}\mathcal{T}(s)$ = $\mathcal{T}(s_{1}) \bigcup \mathcal{T}(s_{2}) \bigcup\mathcal{T}(s_{3})$ }}  \\ \hline
  $t_{1}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\} \\
  $t_{2}$ & \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} \\ \hline
    \end{tabular}%
   % }
\end{table}%


\begin{definition} \label{de:minimalschema}
 A set of the \textbf{minimal} schemas that are only contained in test set $T$ is called the \emph{minimal special schemas} of test set $T$, which is denoted as $\mathcal{C}(T)$.
\end{definition}

Formally, $\mathcal{C}(T)  =  \{s | s \in \mathcal{S}(T)\ and\ \not\exists s' \prec s, s.t., s' \in \mathcal{S}(T)\}$. As an example, let test set $T$ still be \{ \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 0$)\}, \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$), ($p_{4}, 1$)\} \}. $\mathcal{C}(T)$ = \{ \{($p_{1}, 1$), ($p_{2}, 0$), ($p_{3}, 0$)\} \}. Note that other two schemas in $\mathcal{S}(T)$ are the super-schemas of this schema, therefore, they are eliminated from this set.

According to the definition of $\mathcal{C}(T)$, one obvious property is  $\mathcal{C}(T) \subseteq \mathcal{S}(T)$. The second property is that for any schema in $\mathcal{S}(T)$, it must be the super schema of one element of $\mathcal{C}(T)$, i.e., $\forall s \in \mathcal{S}(T), \exists s' \in \mathcal{C}(T), s.t., s' \preceq s$.

We have the following property about the minimal special schema set.

\begin{proposition}[Whole container of minimal special schema set ]\label{pro:ash}
For any test set $T$ of the SUT, $\bigcup_{s \in \mathcal{C}(T)} \mathcal{T}(s) = T$.
\end{proposition}

\begin{proof}
As $\mathcal{C}(T) \subseteq \mathcal{S}(T)$,  it is then obviously $\bigcup_{s \in \mathcal{C}(T)} \mathcal{T}(s) \subseteq \bigcup_{s \in \mathcal{S}(T)} \mathcal{T}(s)$. Hence, we just need to prove that $\bigcup_{s \in \mathcal{S}(T)} \mathcal{T}(s) \subseteq \bigcup_{s \in \mathcal{C}(T)} \mathcal{T}(s)$.

$\forall t \in \bigcup_{s \in \mathcal{S}(T)} \mathcal{T}(s) $, $\exists s \in \mathcal{S}(T),\ s.t., t \in \mathcal{T}(s)$. According to the definition of $\mathcal{C}(T)$, $\exists s' \in \mathcal{C}(T), s.t.,\ s' \preceq s$. Correspondingly $\mathcal{T}(s) \subseteq \mathcal{T}(s')$ by Proposition \ref{pro:shl}. Hence, $t \in \mathcal{T}(s') \subseteq \bigcup_{s \in \mathcal{C}(T)} \mathcal{T}(s)$.

Therefore, $\bigcup_{s \in \mathcal{C}(T)} \mathcal{T}(s) = \bigcup_{s \in \mathcal{S}(T)} \mathcal{T}(s) = T$.
\end{proof}


% Another obvious observation is that
%Then, we have the following proposition.
Next, we consider the minimal special schemas for a subset of test case set $T$.

\begin{lemma} [Minimal special schema of the subset of test set $T$]\label{pro:sbS}
 For any test set $T$ and schema $s$ of the  SUT, if $\mathcal{T}(s) \subseteq T$, then  $s \in \mathcal{S}(T) $.
\end{lemma}
\begin{proof}
 Assume $s \not\in \mathcal{S}(T)$, i.e., $s \not\in \mathcal{I}(T) \backslash \mathcal{I}(\bar{T})$, then $s \in \mathcal{I}(\bar{T})$. It indicates that $\exists t \in \bar{T}, t \in \mathcal{T}(s)$, which contradicts that $\mathcal{T}(s) \subseteq T$. Therefore, $s \in \mathcal{S}(T)$.
\end{proof}


One step further, for two subsuming test case set, we have the relationship between their minimal special schemas as the following.

\begin{proposition}[{Minimal special schemas in the smaller test set}]\label{pro:ssp}
For $T_{1}$ and $T_{2}$ of the SUT with $T_{2} \subseteq T_{1}$, $\forall s_{2} \in \mathcal{C}(T_{2})$, $\exists s_{1} \in \mathcal{C}(T_{1}), s.t.,  s_{1} \preceq s_{2}.$
\end{proposition}

\begin{proof}
$\forall s_{2} \in \mathcal{C}(T_{2})$,  $\mathcal{T}(s_{2}) \subseteq T_{2} \subseteq T_{1}$. According to Lemma \ref{pro:sbS}, $s_{2} \in \mathcal{S}(T_{1})$. By definitions of $\mathcal{S}(T)$ and $\mathcal{C}(T)$, $\exists s_{1} \in \mathcal{C}(T_{1}), s.t., s_{1} \preceq s_{2}$.
\end{proof}

These propositions build the foundation for the analysis of minimal failure-causing schemas we will discuss later.


\subsection{Faulty and healthy}\label{sec:back:failureandhealthy}

We consider any abnormally execution of a test case as a \emph{failure}, e.g., a thrown exception, compilation error, assertion failure or constraint violation. Such a test case (abnormally executed) is called a \emph{failing} case. Otherwise, a test case is a \emph{passing} test case if it normally executed without triggering any failure. In this paper, we focus on the failures that are related with schemas. That is, the failure discussed in this paper is caused by or triggered by specific input schemas.  To facilitate our discussion, we introduce the following two assumptions that will be used throughout this paper:

\begin{assumption}  The execution result of a test case is deterministic.
\end{assumption}

This assumption is a common assumption of CT\cite{zhang2011characterizing,ghandehari2012identifying,niu2013identifying}. It indicates that the outcome of executing a test case is reproducible and will not be affected by some random events. Some approaches have already proposed measures to handle this problem, e.g., studies in \cite{yilmaz2006covering,fouche2009incremental} use multiple covering arrays to avoid this problem, while our previous study gives the multiple execution to alleviate such problem.


\begin{assumption} A failure would always be detected by testers.
\end{assumption}

This assumption shows that we can always observe the failure by failing test case. In practice, some issues may prevent this observation. For example, the coincidental correctness problem \cite{Masri:2014:PCC:2582050.2559932} may happen through testing, when the faulty-code is executed but the failure doesn't propagate to the output. Masking effect \cite{yilmaz2013reducing} may also make the failure-observation difficult, as other failure may triggered and stop the program to go on discovering the remaining failures. Our previous study discussed the problem and some related consequences caused if this assumption does not hold. In this paper, we will also discuss the impacts on caused by these two assumptions, as well as how to alleviate them later.

%Based on these definitions and assumptions, we can get several propositions as following. These propositions are the foundations of the theory of pending schemas.

%When faults are triggered by some test cases, it is desired to figure out the cause of these faults.

Next, let us discuss the relationships between schemas and failures.

\begin{definition}\label{de:faulty}
A schema is \emph{faulty schema} if and only if all the test cases in its \emph{whole set} of containers, i.e., $\mathcal{T}(s)$, are failing test cases.
\end{definition}

%Formally, a schema $s$ is a faulty schema if and only if $\forall t \in \mathcal{T}(c)$, $t$ is a failing test case.
This definition tells that to determine a schema to be faulty schema, we need to make sure all the possible test cases that contain it must be failing test cases. This definition is , because according to .


\begin{definition}\label{de:healthy}
A schema is \emph{healthy schema} if and only if at least one of its whole container is a passing test case.
\end{definition}

Formally, a schema $s$ is healthy schema if and only if $\exists t \in \mathcal{T}(s)$, s.t., $t$ is a passing test case. This definition tells that a healthy schema will not cause the failure of test case because there is at least one passing test case contains it. Note that the healthy schema is the non-faulty schema we introduced in the previous section.


%This definition tells that a schema is called a faulty schema if for any test cases that contain a schema, say $c$, it will trigger a failure.
With respect to healthy schemas and faulty schemas, we conclude the  propositions in this paper.

\begin{proposition}[Sub of Healthy]\label{pro:subofhealthy}
Given a healthy schema $s_{1}$, then $\forall s_{2}, s_{2} \preceq s_{1}$, $s_{2}$ is a healthy schema.
\end{proposition}

\begin{proof}
According to the definition of healthy schema,  there exists at least one test case that contains $s_{1}$ and passes. Let this test case be $t$. Obviously, $s_{1} \preceq t$.  Then $\forall s_{2} \preceq  s_{1}$, we have $s_{2} \preceq s_{1} \preceq t$ according to Proposition \ref{pro:subsumetrans}. Hence, $\forall s_{2} \preceq  s_{1}$,  $t$ contains $s_{2}$ and passes. According to the definition of healthy schema, $\forall s_{2} \preceq  s_{1}$, $s_{2}$ is a healthy schema.
\end{proof}

This proposition shows that any subschema of a healthy schema is also a healthy schema. In fact, this proposition can deduce the first rule in Section \ref{sec:motiv}.


\begin{proposition}[Super of Faulty]\label{pro:superoffaulty}
Given a faulty schema $s_{1}$, then $\forall s_{2}, s_{1} \preceq s_{2}$, $s_{2}$ is a faulty schema.
\end{proposition}


\begin{proof}
let $T_{2}$ be the set of all the test cases that contain $s_{2}$, we have $\forall t_{2} \in T_{2}$, $s_{2} \preceq t_{2}$.  Since $s_{1} \preceq s_{2}$, we have $\forall t_{2} \in T_{2}, s_{1} \preceq s_{2} \preceq t_{2}$ according to the Proposition \ref{pro:subsumetrans}. Hence, $\forall t_{2} \in T_{2}$, $t_{2}$ contains $s_{1}$. According to the definition of faulty schema, any test case which contains $s_{1}$ would fail. Hence, $\forall t_{2} \in T_{2}$, $t_{2}$ is a failing test case. According to the definition of faulty schema. $s_{2}$ is a faulty schema.
\end{proof}

This proposition shows that any super-schema of a faulty schema is also a faulty schema.  Note that his proposition can deduce the second rule in Section \ref{sec:motiv}.


We let the set of failing test cases in the SUT be $T_{fail}$, and the passing test cases in the SUT be $T_{pass}$. Obviously, $T_{pass} = \overline{T_{failing}}$. We can further obtain the relationships between faulty schemas and test cases.

\begin{proposition}[Faulty schemas and failing test set]\label{pro:faultyschemastests}
Given  $T_{fail}$ in the SUT, all the faulty schemas is $\mathcal{S}(T_{fail})$.
%then $\forall s_{2}, s_{1} \preceq s_{2}$, $s_{2}$ is a faulty schema.
\end{proposition}

\begin{proof}
We first prove that, for any schema in $\mathcal{S}(T_{fail})$, it must be a faulty schema.
Obviously $\forall s \in \mathcal{S}(T_{fail})$, $\mathcal{T}(s) \subseteq T_{fail}$ according to Proposition \ref{pro:stct}, indicating that $s$ is a faulty schema according to the definition of faulty schema.

We second prove that, for any other schema that does not belong to $\mathcal{S}(T_{fail})$, it must be a healthy schema.
Since $s \notin \mathcal{S}(T_{fail})$, i.e., $s \notin \mathcal{I}(T_{fail}) \backslash \mathcal{I}(T_{pass})$, then $s \in \mathcal{I}(T_{pass})$. Consequently, $\exists t \in T_{pass}, s \preceq t$. Hence, $s$ is a healthy schema according to the definition.
% $\mathcal{T}(s) \subset T_{fail}$
\end{proof}

\begin{proposition}[Healty schemas and passing test set]\label{pro:healthyschemastests}
Given  $T_{pass}$ in the SUT, all the healthy schemas is $\mathcal{I}(T_{pass})$.
\end{proposition}

%
%
%\begin{proposition}[Faulty schema]\label{pro:faultyschema}
%Given a set of failing test cases  $T_{fail}$, the faulty schema is then $\forall s_{2}, s_{2} \preceq s_{1}$, $s_{2}$ is a healthy schema.
%\end{proposition}

\begin{definition} \label{de:faulty:minimal}
The minimal set of schemas of the faulty schemas are called \emph{minimal failure-causing schema (MFS)} \cite{nie2011minimal}.
%Based on this, if a test case $t$ hit such a failure-inducing combination, say $c(F)$, it should trigger the fault $F$, for which the test case can be put as $t(F)$
\end{definition}

\begin{proposition}[Minimal failure-causing schemas and failing test set]\label{pro:minmalfaultyschemastests}
Given  $T_{fail}$ in the SUT, all the MFS is $\mathcal{C}(T_{fail})$.
%then $\forall s_{2}, s_{1} \preceq s_{2}$, $s_{2}$ is a faulty schema.
\end{proposition}

%Note that MFS is identical to the failure-inducing interaction mentioned previously. %In this paper, the terms \emph{failure-inducing interactions} and \emph{MFS} are used interchangeably.
Figuring the MFS helps to identify the root cause of a failure and thus facilitate the debugging process.


%\begin{definition}\label{de:healthy:maximal}
%A schema, say, $c$, is called a \emph{healthy schema} when we find at least one passing test case that contains this schema. In addition, if none of super-schema of $c$ except itself is the \emph{healthy schema}, we then call the schema $c$ the \emph{maximal healthy schema (MHS)}.
%\end{definition}
%
%The healthy schema is exactly the non-faulty schema we mentioned before. These two type of schemas, i.e., MFS and MHS, are essentially representations of the healthy schemas and faulty schemas in a test case. As shown later, other schemas can be determined to be healthy or faulty by these two type of schemas. As a result, we just need to record these two types of schemas (normally a small amount) instead of recording all the schemas in a test case (up to $2^{n}$) when identifying MFS.


%, and their proofs are omitted due to their simplicity.


%The following two propositions are proposed in our previous study [multi].
%
%\begin{corollary}[Minimal failure-causing schemas]\label{pro:mfsinthesut}
%Minimal failure-causing schemas must be $\mathcal{C}(T_{fail})$.
%%For any test set $T$ of the SUT, $\bigcup_{c \in \mathcal{C}(T)} \mathcal{T}(c) = T$.
%\end{corollary}

%
%\begin{proposition}[{minimal schemas in the smaller test set}]\label{pro:ssp}
%For two sets of test cases $T_{1}$ and $T_{2}$ of the SUT with $T_{2} \subseteq T_{1}$, $\forall c_{2} \in \mathcal{C}(T_{2})$, $\exists c_{1} \in \mathcal{C}(T_{1}), s.t., c_{1} \preceq c_{2}$.
%\end{proposition}


\section{The determination of schemas}\label{sec:pending}
In this section, we will give the formal definition of the pending schema, as well as its properties. Based on several theoretical analysis about pending schema, we will give an efficient approach to obtain them. Then we will show a case study of  how to apply this approach on identifying the pending schemas.
%To give a better description, we will give several propositions which provide theoretical supports for our approach. The proofs of these propositions are given in the Appendix.

\subsection{The determinable schemas}\label{sec:pending:determinable}
Before we give a formal definition of pending schema, we need to first give the definition of ``a determinable schema". Note that in Section \ref{sec:back}, we introduced the definition of faulty schema and healthy schema, as well as some properties of them. Based on these definitions, we can conclude that in order to determine a schemas to be healthy or faulty, we need to make sure whether the corresponding schema satisfies the specific conditions. For example, if we find the condition that a schema appears in one passing test case holds, then this schema is a healthy schema. Hence, if these conditions hold by given information or can be deduced from given information, we can determine the the schema to be healthy or faulty. Otherwise, we cannot determine the state of the schema for lack of information. Next, we will give the definition of the determinable schema.

%Given the results of the test cases or some schemas. This is the information.

\begin{definition}\label{de:deteminable}
A schema is determinable if and only if it is determined to be healthy schema or faulty schema according to given information.
\end{definition}

Here, the ``information'' indicates the outcomes of the execution of some test cases or the determination state of existed schemas. If we are given the outcomes of all the test cases in the SUT or the determination results of all the possible schemas in the SUT, then for any schema in the SUT, we can easily determine it to be faulty or healthy. However, if only partial information is given, it is obvious that not all the schemas are determinable.

Next, we will discuss the determination of schemas under a particular circumstance, which consists of a given set of passing test case and a set of minimal faulty schemas. This circumstance is important to analyse the properties of schemas for MFS identification later.

%First, consider the determinable schemas when given a set of passing test cases.
%\begin{proposition}[Determinable with passing test cases]\label{pro:determinableparthealthy}
%Given a set of passing test case set $PTS$, $\forall s$ is determinable if only if $\exists t \in PTS, s \preceq t$.
%\end{proposition}
%
%\begin{proof}
%We prove by two steps. First, we prove that if $\exists t \in PTS, s \preceq t$, $s$ is determinable.
%
%Note that $\forall t \in PTS$, $t$ is a healthy schema. This is because $t \preceq t$, and $t$ is a passing test case. Hence, $t$ itself is a healthy schema according to the definition. Hence, $\forall s \preceq t$, $s$ is also a healthy schema according to Proposition \ref{pro:subofhealthy}, indicating that $s$ is determinable.
%
%Second, we prove that if $s$ is determinable, it has $\exists t \in PTS, s \preceq t$.
%
%If $s$ is determinable, then $s$ is either a healthy schema or faulty schema according to some given information.
%
%Let us first assume that $s$ is determined to be a heathy schema. Then according to the definition, $\exists t, s \preceq t$, $t$ is a passing test case. Since the given passing test case set is $PTS$. It must have $t \in PTS$ (Other test cases do not necessary to be passing test cases). Hence, it has $\exists t \in PTS, s \preceq t$.
%
%Let us then assume that $s$ is determined to be a faulty schema.  According to the definition, $\forall t, s \preceq t$, $t$ is a failing test case. However, these is no failing test case given at first (all the test cases in $PTS$ are passing test cases, and other test cases do not necessary to be failing test case). Hence, we cannot make sure $s$ is a faulty schema. This is contradiction, indicating that $s$ cannot be determinable to be faulty schema.
%
%Combining these two conditions, we prove that if $s$ is determinable, it has $\exists t \in PTS, s \preceq t$.
%
%\end{proof}
%
%Proposition \ref{pro:determinableparthealthy} tells that if given a set of passing test cases, only the schemas that contained in these passing test cases are determinable, and these schemas must be determined to be healthy schemas.
%
%Second, consider the determinable schemas when given a set of MFS.
%
%\begin{proposition}[Determinable with MFS]\label{pro:determinablepartfaulty}
%Given a set of Minimal Failure-causing Schemas $MFSS$, $\forall s$ is determinable if only if $\exists m \in MFSS, m \preceq s$.
%\end{proposition}
%
%\begin{proof}
%
%Similarly, we prove this proposition by two steps. First, we prove that if $\exists m \in MFSS, m \preceq s$, $s$ is determinable.
%
%Since $\forall m \in MFSS$, $m$ is faulty schema, hence according to Proposition \ref{pro:superoffaulty}, $s$ is a faulty schema. It indicates that $s$ is determinable.
%
%Second, we prove that if $s$ is determinable, it has $\exists m \in MFSS, m \preceq s$.
%
%If $s$ is determinable, then $s$ is either a healthy schema or faulty schema according to some given information.
%
%Let us first assume that $s$ is determined to be a heathy schema. According to the definition, $\exists t, s \preceq t$, $t$ is a passing test case. However, there is no guarantee that some specific test case must be passing test case. In fact, all the test cases in the SUT could be failing test cases, which is compatible with the given condition (We are only given a set of minimal faulty schemas). Hence, $s$ cannot to be determined to be a healthy schema.
%
%Then we assume that $s$ is determined to be a faulty schema. We need to prove it has $\exists m \in MFSS, m \preceq s$.
%We prove this by contradiction. We assume that $\nexists m \in MFSS, m \preceq s$.
%
%As a result, there are only two possible relationships between $s$ and $MFSS$. First, $\exists m \in MFSS, s \preceq m$. This is obviously not true, as all the schemas in $MFSS$ are minimal. Second, $\forall m \in MFSS$, $s \npreceq m$ and $m \npreceq s$. This is also not possible (We prove it in the Appendix). Since, these two conditions are all not hold, the assumption is not hold. Consequently, the only possible relationship between $s$ and $MFSS$ is $\exists m \in MFSS, m \preceq s$.
%
%Combining these two conditions, we prove that if $s$ is determinable, it has $\exists m \in MFSS, m \preceq s$.
%\end{proof}
%
%Proposition \ref{pro:determinableparthealthy} tells that if given a set of minimal faulty schemas, only the schemas that are the super-schemas of these faulty schemas  are determinable, and these schemas must be determined to be faulty schemas.
%
%
%Next, we consider the combination of the two particular circumstances.

%Before we give this circumstance, we need to first consider when give.


\begin{proposition}[Determinable with passing test cases and faulty schemas]\label{pro:determinableparthealthyfaulty}
Given a set of passing test case set $PTS$, and a set of minimal faulty schemas $MFSS$, for any schema, say, $s$, is determinable if only if either $\exists t \in PTS, s \preceq t$ or $\exists m \in MFSS, m \preceq s$.
\end{proposition}

\begin{proof}

We prove this proposition by two steps. First, we prove that if either $\exists t \in PTS, s \preceq t$ or $\exists m \in MFSS, m \preceq s$, $s$ is determinable.

Note that $\forall t \in PTS$, $t$ is a healthy schema. This is because $t \preceq t$, and $t$ is a passing test case. Hence, $t$ itself is a healthy schema according to the definition. Hence, $\forall s \preceq t$, $s$ is also a healthy schema according to Proposition \ref{pro:subofhealthy}, indicating that if $\exists t \in PTS, s \preceq t$, $s$ is determinable (determined to be healthy schema).

Also since $\forall m \in MFSS$, $m$ is faulty schema, hence according to Proposition \ref{pro:superoffaulty}, $\forall s,  m \preceq s$, $s$ is a faulty schema. It indicates that if $\exists m \in MFSS, m \preceq s$, $s$ is determinable (determined to be faulty schema).


%as proved in Proposition \ref{pro:determinableparthealthy}, $s$ is determinable and is determined to be a healthy schema. If $\exists m \in MFSS, m \preceq s$, as proved in Proposition \ref{pro:determinablepartfaulty}, $s$ is also determinable and determined to be a faulty schema.

Next, we prove that if $s$ is determinable, then either $\exists t \in PTS, s \preceq t$ or $\exists m \in MFSS, m \preceq s$.

Let us first assume that $s$ is determined to be a heathy schema. Then according to the definition, $\exists t, s \preceq t$, $t$ is a passing test case. Since the given passing test case set is $PTS$, and the minimal faulty schema set $MFSS$ cannot guarantee any test case to be passing (It can only guarantee the test cases contain the schemas in $MFSS$ to be failing test csaes). It must have $t \in PTS$, because other test cases do not necessary to be passing test cases (In fact, it is possible that all these remaining test cases are failing test cases). Hence, if $s$ is determined to be a heathy schema it has $\exists t \in PTS, s \preceq t$.

Let us then assume that $s$ is determined to be a faulty schema.  According to the definition, $\forall t, s \preceq t$, $t$ is a failing test case. However, all the test cases in $PTS$ are passing test cases, $MFSS$ can guarantee a set of failing test cases, which are $T(MFSS)$ = $\{ t | \exists m \in MFSS, m \preceq t \}$. Besides, other test cases do not necessary to be failing test cases.  Hence, it must have $\forall t, s \preceq t$, $t \in T(MFSS)$. That is, $T(s) \subseteq T(MFSS)$. According to Proposition \ref{pro:ssp}, we have $\exists m \in \mathcal{C}(T(MFSS))$, $m \preceq s$, which is equal to  $\exists m \in MFSS$, $m \preceq s$. Hence,  if $s$ is determined to be a faulty schema it has  $\exists m \in MFSS$, $m \preceq s$.

 %cannot make sure $s$ is a faulty schema. This is contradiction, indicating that $s$ cannot be determinable to be faulty schema.

%Then we assume that $s$ is determined to be a faulty schema. We need to prove it has $\exists m \in MFSS, m \preceq s$.
%We prove this by contradiction. We assume that $\nexists m \in MFSS, m \preceq s$.
%
%As a result, there are only two possible relationships between $s$ and $MFSS$. First, $\exists m \in MFSS, s \preceq m$. This is obviously not true, as all the schemas in $MFSS$ are minimal. Second, $\forall m \in MFSS$, $s \npreceq m$ and $m \npreceq s$. This is also not possible (We prove it in the Appendix). Since, these two conditions are all not hold, the assumption is not hold. Consequently, the only possible relationship between $s$ and $MFSS$ is $\exists m \in MFSS, m \preceq s$.

%Combining these two conditions, we prove that if $s$ is determinable, it has $\exists m \in MFSS, m \preceq s$.

\end{proof}

Proposition \ref{pro:determinableparthealthyfaulty} tells that if given a set of passing test cases $PTS$ and minimal faulty schemas $MFSS$, only the schemas that are the super-schemas of these faulty schemas or subschemas in the passing test cases are determinable.  More formally, the set of the determinable schemas are

\begin{equation}
\begin{aligned}\label{eq:dss}
DSS=\{ s\ |\ \exists t \in PTS,  s \preceq t  \ || \  \exists m \in MFSS, m \preceq s \} .
\end{aligned}
\end{equation}
%
% $$DSS = \{ $s | \exists t \in PTS, s \preceq t$ or $\exists m \in MFSS, m \preceq s  \} $$
%%, and these schemas must be determined to be faulty schemas.

%given a set of faulty schemas, of which satisfying that no other schemas of its faulty is faulty schema (This is the definition of MFS identification).


%According to this definition, to tell a schema is determinable or not we need to check if it is a healthy schema or faulty schema.  Next, we will discuss under which conditions does a schema is determinable.

%More formally, let $stat(s, pass)$  = true is the proposition that show a schema is true. This is true if and only if $\exists t, s \preceq t$, t is a passing test case.  Similarly,  let $stat(s, fail)$  = true is the proposition that show  a schema is faulty. This is true if and only if $\forall t, s \preceq t$, t is a failing test case. If we can know all the information of all the test cases in the SUT, we can easily judge the correctness of each function for any schema. However, if we have only partial information of the SUT, not all the schemas is determinable.
%
%Let us consider the general condition, when given a set of schemas of which the status is known. Formally, let $HSS$ be the set of the schemas of which the stat is determined to be healthy, i.e., $\forall s \in HSS, stat(s, pass) = true$ is solvable (can find satisfied test cases). Let $FSS$ be the set of the schemas of which the stat is determined to be faulty, i.e., $\forall s \in FSS, stat(s, fail) = true$ (can find satisfied test cases).  Then for any schema $s$, can we determined this schema to be healthy or faulty? Note that here we did not take the test cases as a knowledge, but instead of schemas, because schemas are more general (test cases themselves are schemas). Another reason is that schemas are more applicable if we obtain the information by MFS identification (they do not only offer the information of test cases, but also the schemas (MFS)).
%
%
%\begin{proposition}[Determinable to be healthy with part set]\label{pro:determinableparthealthy}
%Given $HSS$, $s$ is determined to he healthy if only if $stat(s, fail) \&\& stat(s_{i}, pass) \&\& stat(s_{j}, fail)$ is unsolvable.
%\end{proposition}
%
%Note that this formula is unsolvable, if and only if $stat(s, fail)$ is not true. Hence, it can only be $stat(s, true)$ be true. Hence, $s$ must be a healthy schema.  (can be provable.)
%
%%
%%\begin{proposition}[Determinable to be healthy with part set]\label{pro:determinableparthealthy}
%%Given $HSS$, $s$ is determined to he healthy if only if $stat(s, fail) \&\& stat(s_{1}, pass) \&\& ... \&\& stat(s_{i}, pass) \&\& stat(s_{i}, pass)$ is unsolvable.
%%\end{proposition}
%%
%%Note that this formula is unsolvable, if and only if $stat(s, fail)$ is not true. Hence, it can only be $stat(s, true)$ be true. Hence, $s$ must be a healthy schema.  (can be provable.)
%
%\begin{proposition}[Determinable to be faulty with part set]\label{pro:determinableparthealthy}
%Given $FSS$, $s$ is determined to he faulty if only if $stat(s, pass) \&\& stat(s_{i}, pass) \&\& stat(s_{j}, fail)$ is unsolvable.
%\end{proposition}
%
%Note that this formula is unsolvable, if and only if $stat(s, pass)$ is not true. Hence, it can only be $stat(s, fail)$ be true. Hence, $s$ must be a faulty schema.  (can be provable.)



\subsection{The pending schemas}\label{sec:pending:pending}

After the introduction of determinable schemas and their properties, we can easily define the undetermined schemas, i.e., the pending schemas.
%Through these motivating examples, we can learn that the pending schema is not checked to be healthy and faulty. Hence, we give the definition of the pending schema as follows.

\begin{definition}\label{de:pending}
A schema is called a \textbf{\emph{pending} schema}, if and only if it cannot be determined to be healthy schema or faulty schema according to given information.
\end{definition}


%\begin{definition}\label{de:deteminable}
%A schema is determinable if and only if it is determined to be healthy schema or faulty schema according to given information.
%\end{definition}
From this definition, it is obvious that the pending schema is the converse of determinable schema. That is, with given information, if a schema is determinable, then it is not a pending schema; and if it is not determinable, it must be a pending schema. The \emph{pending} schema is actually the \emph{cannot-be-determined} schema discussed in Section \ref{sec:intro} and Section \ref{sec:motiv}, which is the key schema we focus on in this paper. To analyse the pending schemas in one failing test case is important to evaluate the completeness of the test.  Next, we will give the first property about the pending schema.


%However, we give the more general condition. We normally did not the pending schemas, but the faulty schemas and healthy schemas.
%Next, we give the determinable of pending
%
%
%\begin{proposition}[Pending o be healthy with part set]
%Given $HSS$ and $FSS$, $s$ is pending schema if and  only if $stat(s, fail) \&\& stat(s_{i}, pass) \&\&$ $stat(s_{j}, fail)$ and $stat(s, pass) \&\&$ $stat(s_{i}, pass)$ $\&\& stat(s_{j}, fail)$ are both solvable.
%\end{proposition}
%
%If the first is solvable, then it is not must be a healthy schema. The second shows that it is not necessarily a faulty schema. This indicates that this schema can be healthy or faulty. That is, its state is not decidable. This is also we called a pending schema.

%However, to emulate all the faulty schemas and all the healthy schemas is very large. By the propostios 3 and 4,
%
%More formally, we can learn that it should not be any super-schemas of existing faulty schemas, and any sub-shemas of existing healthy schemas.
\begin{proposition}[Sandwich rule]\label{pro:pendingsandwich}
Given two pending schemas $s_{1}$, $s_{2}$, and $s_{1} \preceq s_{2}$. Then $\forall s_{3}, s_{1} \preceq s_{3} \preceq s_{2}$, $s_{3}$ is a pending schema.
\end{proposition}

\begin{proof}
We give the proof by contradiction. First, we assume that $s_{3}$ is a faulty schema. Since $s_{3} \preceq s_{2}$, then according to Proposition \ref{pro:superoffaulty}, $s_{2}$ is also a faulty schema. This is contradiction as $s_{2}$ is a pending schema. Hence, $s_{3}$ is not a faulty schema. Next, we assume that $s_{3}$ is a healthy schema.  Since $s_{1} \preceq s_{3}$, then according to Proposition \ref{pro:subofhealthy}, $s_{1}$ is also a healthy schema. This is also contradiction as $s_{1}$ is a pending schema.  Hence, $s_{3}$ is not a healthy schema. At last, according to the definition of pending schema, $s_{3}$ is a pending schema.
\end{proof}

This proposition gives the determination of pending schemas in the presence of two subsuming pending schemas.

Similarly as the determinable schemas, we will discuss the pending schemas for the circumstance with a given set of passing test case and a set of minimal faulty schemas.

%This circumstance is important to analyse the properties of schemas for MFS identification later.

\begin{proposition}[pending with passing test cases and minimal faulty schemas]\label{pro:pendingparthealthyfaulty}
Given a set of passing test case set $PTS$, and a set of minimal faulty schemas $MFSS$, for any schema, say, $s$, is pending schemas if only if $\forall t \in PTS, s \npreceq t$ and $\forall m \in MFSS, m \npreceq s$.
\end{proposition}

The proof of this proposition is omitted (can be easily deduced based on Proposition \ref{pro:determinableparthealthyfaulty}). Proposition \ref{pro:pendingparthealthyfaulty} tells that if given a set of passing test cases $PTS$ and minimal faulty schemas $MFSS$, only the schemas that are neither the super-schemas of these faulty schemas nor subschemas in the passing test cases are pending schemas.  More formally, the set of the pending schemas are

\begin{equation}
\begin{aligned}\label{eq:pss}
PSS=\{ s\ |\ \forall t \in PTS,  s \npreceq t  \ \&\& \  \forall m \in MFSS, m \npreceq s \}.
\end{aligned}
\end{equation}

It is obviously $PSS$ and $DSS$ are complemented.

%Note that if it is not nessearily fulfiled, it will turn to be deteminable schemas.
%
%Let this be a possible set of pending schema.
%
%Then just use it to remove some kinds of schemas, it is possible that .

%
%Note that this formula is unsolvable, if and only if $stat(s, fail)$ is not true. Hence, it can only be $stat(s, true)$ be true. Hence, $s$ must be a healthy schema.  (can be provable.)

\section{Obtaining the pending schemas in one failing test case}\label{sec:pending:obtaining}

In the previous section, we have already obtained the formula to describe the set of pending schemas for given information. However, this set is usually too large and contains many schemas that never appear in any generated test cases (These schemas are evidently pending schemas). In this paper, we only focus on these schemas that have already appeared in the generated test cases. This is because after testing and MFS identification, testers may have a false confidence on the fact that all the schemas appeared in these test cases are determinable, which may result in hidden dangers to the system under testing if the fact is not true (some of them are not determinable).
% but the fact is the extences of the pending schemas in these test cases, the testing and MFS identification is still not complete. Consequently, we only focus the pending schemas that appeared in the generated test cases.

%Since all the schemas in the passing test cases are determinable (healthy), what we focus is the pending schemas in the failing test cases.

More formally,  given a failing test case $t$ =\{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, ..., $(p_{n}, v_{n})$\},  a set of passing test cases $PTS$ = \{ $t_{1}, t_{2}, ... t_{i}, ...$\}, and a set of minimal faulty schemas $MFSS$ = \{ $m_{1}, m_{2}, ... m_{i}, ...$ \}, our goal is to find the set of pending schemas in test case $t$.


We will settle this problem step by step.  According to Formula \ref{eq:pss}, we can easily obtain the pending schemas in the failing test case are in the following set.

%the $\forall s $, $s \in HSS$ or $\forall s \in HSS, s' \prec s$ is a healthy schema. That is $s \preceq s' in HSS$ is healthy schema. Note that according to these information (We cannot generate and execute more test cases to obtain more information), we can only dong this. Second, .

% and \ref{pro:superoffaulty}, it is easy to find that, the pending schemas set PSS should be the following set
\begin{equation}
\begin{aligned}\label{eq:pssfirst}
PSS=\{ s\ |\ s \preceq t\ \&\&\ \forall m \in MFSS,  m \npreceq s  \ \&\&\  \forall t_{i} \in PTS, s \npreceq t_{i} \} .
\end{aligned}
\end{equation}

%\begin{proof}
%\end{proof}

%To obtain one pending schema, we just need to select one schema which satisfies $ c \in PSS$.
However, to directly utilize Formula \ref{eq:pssfirst} is not practical to obtain the pending schemas, because in the worst case it needs to check every schema in a test case $t$. Note that the number of schemas in $t$ is $2^{n} - 1$, where $n$ is the number of factors in this test case. For each schema we need to check whether it is the sub-schemas of any test case in $PSS$ (the number of the test cases in $PTS$ is |$PTS$|). We also need to check whether it is the super-schemas of any faulty schemas in $MFSS$ (the number of the faulty schemas in $MFSS$ is |$MFSS$|). As a result, the complexity of directly utilizing Formula \ref{eq:pssfirst} is $2^{n} \times |PTS| \times |MFSS|$, which is infeasible to handle when $n$ is large. Hence, we need to find another formula which is equivalent to Formula \ref{eq:pssfirst}, but with much lower complexity.

Our first step is to reduce the number of minimal faulty schemas to be checked for a pending schema.  For this, let $MFSS_{t}$ be the minimal faulty schemas that are the subschemas of test case $t$. That is, $MFSS^{t}$ = $\{ s\ | \ s \in MFSS, s \preceq t \}$.  It is obvious that the complexity of obtaining $MFSS^{t}$ from $MFSS$ is $O(|MFSS|)$.

%Let $MFSS^{t\circ}$ = $MFSS \backslash MFSS^{t}$.

%We have the following propositions.

\begin{proposition}\label{pro:mfssintequal}
Let schema set $A$ = $\{ s\ |\ s \preceq t\ \&\&\ \forall m \in MFSS,  m \npreceq s \}$,  schema set $B$ = $\{ s\ |\ s \preceq t\ \&\&\ \forall m \in MFSS^{t},  m \npreceq s \}$. Then we have $A = B$.
\end{proposition}

\begin{proof}

A = $\{ s\ |\  s \preceq t\ \&\&\ \forall m \in MFSS,  m \npreceq s \}$
 =
$\{ s\ |\  s \preceq t\ \&\&\ \forall m \in MFSS^{t},  m \npreceq s \&\&\   \forall m \in MFSS \backslash MFSS^{t},  m \npreceq s  \}$

Since $MFSS \backslash MFSS^{t}$ = $\{ m \ | \ m \in MFSS, m \npreceq t \}$.

Hence, $\forall s \preceq t, m \in MFSS \backslash MFSS^{t},  m \npreceq s$ (Otherwise, $m \preceq s \preceq t$, which is contradiction).

Since the condition $\forall s \preceq t, \forall m \in MFSS \backslash MFSS^{t},  m \npreceq s $ does always hold, therefore, A =
$\{ s\ |\  s \preceq t\ \&\&\ \forall m \in MFSS^{t},  m \npreceq s \&\&\   \forall m \in MFSS \backslash MFSS^{t},  m \npreceq s  \}$  =
$\{ s\ |\  s \preceq t\ \&\&\ \forall m \in MFSS^{t},  m \npreceq s \}$ = B.
\end{proof}

With this proposition, we only need to focus on the minimal faulty schemas that only contained in the failing test case $t$ instead of all the possible minimal faulty schemas to obtain the pending schemas. %hence, reduce the number of faulty schemas.

Next, we consider to reduce the number of passing test cases to be checked for a pending schema.

Let $PTS^{t}$ be the schemas that are intersection subschemas between each test case in $PTS$ and test case $t$. That is, $PTS^{t}$ = $\{ s\ | \exists t' \in  PTS, s\ =\ t' \cap t \}$. Note that to obtain $PTS^{t}$ from $PTS$, the complexity is $O(|PTS|)$.  It is easy to know that $\forall s \in PTS^{t}, s \preceq t \ \&\& \ \exists s' \in PTS, s \preceq s'$.


\begin{proposition}\label{pro:healthysintequal}
Let schema set $A$ = $\{ s\ |\ s \preceq t\ \&\&\  \forall t_{i} \in PTS, s \npreceq t_{i} \} $,  schema set $B$ = $\{ s\ |\ s \preceq t\ \&\&\ \forall p \in PTS^{t}, s \npreceq p \}$. Then we have $A = B$.
\end{proposition}

\begin{proof}
Note that $PTS^{t}$ = $\{ s\ |\exists t' \in PTS, s =  t' \cap t \}$.
%and we have $\forall s \in PTS^{t}, s \preceq t \&\& \exists t' \in PTS, s \preceq t'$.

We first prove that $A \subseteq B$. Note for each $s \in A$, we have $s \preceq t \&\& \forall t_{i} \in PTS, s \npreceq t_{i}$. We assume that $\exists s \in A, \exists s' \in PTS^{t}, s \preceq s'$. For $s'$, $\exists t' \in PTS, s' \preceq t'$. Hence, $s  \preceq s' \preceq t'$. This is contradiction. Hence the assumption does not hold, indicating that $\forall s \in A, \forall s' \in PTS^{t}, s \npreceq s' \&\& s \preceq t$. That is $\forall s \in A$, $s \in B$. Hence, $A \subseteq B$.

Next we prove that $B \subseteq A$. Since $\forall s \in B$, we have $s \preceq t \&\& \forall t_{i} \in  PTS^{t}, s \npreceq t_{i}$. We assume that $\exists s \in B, \exists t' \in PTS, s \preceq t'$. Also $s \preceq t$, which indicates that $s \preceq (t \cap t')$.  Since $(t \cap t') \in PTS^{t} $, $\exists s \in B, \exists t_{i} \in PTS^{t}, s \preceq t_{i}$. This is contradiction, indicating that  $\forall s \in B, \forall t' \in PTS, s \npreceq t' \&\& s \preceq t$. That is, $\forall s \in B$, $s \in A$. Hence, $B \subseteq A$.

Since we have $A \subseteq B$ and $B \subseteq A$, we have $A = B$.
\end{proof}

With this proposition, we do not need to check each passing test case. Instead, we only need to focus on the intersection part of passing test cases and the failing test case.

We can further reduce the number of schemas need to checked. Let $PTS^{t\bigtriangleup}$ be the maximal schemas in $PTS^{t}$. That is, $PTS^{t\bigtriangleup}$ = $\{ s\ |  s \in PTS^{t} \&\& \nexists s'  \in PTS^{t}, s \prec s' \}$.  To obtain $PTS^{t\bigtriangleup}$ from $PTS$ with complexity of $O(|PTS|^{2})$. It is easy to know that $\forall s \in PTS^{t}, \exists s' \in PTS^{t\bigtriangleup},  s \preceq s'$.

\begin{proposition}\label{pro:healthysintequal2}
Let schema set $A$ = $\{ s\ |\ s \preceq t\ \&\&\ \forall p \in PTS^{t}, s \npreceq p \}$, schema set $B$ = $\{ s\ |\ s \preceq t\ \&\&\ \forall p \in PTS^{t\bigtriangleup}, s \npreceq p \}$. Then we have $A = B$.
\end{proposition}

\begin{proof}

First, we will prove $A \subseteq B$.

Since $PTS^{t\bigtriangleup} \subseteq PTS^{t}$, we have $  \{ s | \forall p \in PTS^{t}, s \npreceq p \} =  \{ s | \forall p \in PTS^{t\bigtriangleup}, s \npreceq p \ \&\& \  \forall p \in PTS^{t} \backslash PTS^{t\bigtriangleup}, s \npreceq p \} \subseteq \{ s | \forall p \in PTS^{t\bigtriangleup}, s \npreceq p \}$. Hence,  $\{ s\ |\ s \preceq t\ \&\&\ \forall p \in PTS^{t}, s \npreceq p \} \subseteq  \{ s\ |\ s \preceq t\ \&\&\ \forall p \in PTS^{t\bigtriangleup}, s \npreceq p \}$. That is,  $A \subseteq B$.

Next, we will prove $B \subseteq A$.

We assume that  $\exists s \in  \{ s | \forall p \in PTS^{t\bigtriangleup}, s \npreceq p \}$, $ s \notin \{ s | \forall p \in PTS^{t}, s \npreceq p \}$. It indicates that $\exists p' \in PTS^{t}, s \preceq p'$. Since $p' \in PTS^{t}$, $\exists p'' \in PTS^{t\bigtriangleup}, p' \preceq p''$. It has $s \preceq p' \preceq p''$. This is contradiction.  Hence, the assumption does not hold, indicating that $\forall s \in  \{ s | \forall p \in PTS^{t\bigtriangleup}$, $s \in  \{ s | \forall p \in PTS^{t}, s \npreceq p \}$. Hence, $\{ s | \forall p \in PTS^{t\bigtriangleup}$ $\subseteq$ $\{ s | \forall p \in PTS^{t}, s \npreceq p \}$. Therefore, $\{ s\ |\ s \preceq t\ \&\&\ \forall p \in PTS^{t\bigtriangleup}, s \npreceq p \}$ $\subseteq$ $\{ s\ |\ s \preceq t\ \&\&\ \forall p \in PTS^{t}, s \npreceq p \} $. That is $B \subseteq A$.

As we have shown B $\subseteq$ A, and A $\subseteq$ B, so A = B.
\end{proof}

With this proposition, we do not need to check each schema in $PTS^{t}$, instead, we only need to focus on the maximal schemas in this set.

With these two set of schemas, we can obtain the second formula to compute the pending schemas in a failing test case $t$, which is listed in the following.

\begin{equation}
\begin{aligned}\label{eq:pssfirst_mutated}
PSS=\{ s\ |\ s \preceq t\ \&\&\ \forall m \in MFSS^{t},  m \npreceq s  \ \&\&\  \forall p \in PTS^{t\bigtriangleup}, s \npreceq p \} .
\end{aligned}
\end{equation}

\begin{proof}

Let A = $\{ s\ |\  s \preceq t\ \&\&\ \forall m \in MFSS,  m \npreceq s \}$, B = $ \{ s\ |\ s \preceq t\ \&\&  \forall p \in PTS, s \npreceq p \} $. Obviously, PSS = $A \cap B$.

According to Proposition \ref{pro:mfssintequal}, A = $\{ s\ |\  s \preceq t\ \&\&\ \forall m \in MFSS^{t},  m \npreceq s \}$.
According to Proposition \ref{pro:healthysintequal} and Proposition \ref{pro:healthysintequal2}, B = $\{ s\ |\  s \preceq t\ \&\&\ \forall p \in PTS^{t},  s \npreceq p \}$ = $\{ s\ |\  s \preceq t\ \&\&\ \forall p \in PTS^{t\bigtriangleup},  s \npreceq p \}$.

Hence, $PSS$ = $A \cap B$ = $\{ s\ |\  s \preceq t\ \&\&\ \forall m \in MFSS^{t},  m \npreceq s \}$ $\cap$ $\{ s\ |\  s \preceq t\ \&\&\ \forall p \in PTS^{t\bigtriangleup},  s \npreceq p \}$ = $\{ s\ |\ s \preceq t\ \&\&\ \forall m \in MFSS^{t},  m \npreceq s  \ \&\&\  \forall p \in PTS^{t\bigtriangleup}, s \npreceq p \}$.
\end{proof}


With respect to Formula \ref{eq:pssfirst_mutated}, the complexity of obtaining the pending schemas is computed as follows. We first need to obtain $MFSS^{t}$ and $PTS^{t\bigtriangleup}$, for which the complexities are $O(|MFSS|)$ and $O(|PTS|^{2})$. Then we still need to check each schema in test case $t$, to figure whether it is subschema of some schema in $PTS^{t\bigtriangleup}$ or super-schema of some schema in $MFSS^{t}$, for which the complexity is $O(2^{n}* |MFSS^{t}| * |PTS^{t\bigtriangleup}|)$, where $n$ is the number of factors in the test case.  At last, the complexity is $O(|MFSS| + |PTS|^{2} + 2^{n}* |MFSS^{t}| * |PTS^{t\bigtriangleup}| )$. Obviously, this is still not feasible when $n$ is large.



Next, we will try to eliminate the influence of the number of $n$ to obtain the pending schemas. For this purpose, we defined the following two sets, i.e. $CMXS$ and $CMNS$.

\begin{definition}
For a $k$-degree schema $s$ = \{$(p_{x_{1}}, v_{x_{1}})$, $(p_{x_{2}}, v_{x_{2}})$, ..., $(p_{x_{k}}, v_{x_{k}})$\}, a test case $t$ = \{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, ..., $(p_{n}, v_{n})$\}, and $s \preceq t$. We denote the candidate maximal non-super schema set as $CMXS(s,t)$ = \{$t \backslash (p_{x_{i}}, v_{x_{i}})$ | $(p_{x_{i}}, v_{x_{i}}) \in s $\}.
\end{definition}

Note that $CMXS$ is the set of schemas that remove one distinct factor value in $s$, such that all these schemas will not be the super-schema of $s$. For example assume the test case \{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, $(p_{3}, v_{3})$, $(p_{4}, v_{4})$\}, and a schema \{$(p_{1}, v_{1})$, $(p_{3}, v_{3})$\}. Then the CMXS set is \{ \{$(p_{2}, v_{2})$,  $(p_{3}, v_{3})$, $(p_{4}, v_{4})$\}, \{$(p_{1}, v_{1})$,  $(p_{2}, v_{2})$, $(p_{4}, v_{4})$\} \}. Obviously, the complexity of obtaining $CMXS$ with respect to one schema and one test case is O($\tau$), where $\tau$ is the number of parameter values in this faulty schema, i.e., the degree of this schema.

With respect to the $CMXS$ set of a single schema, we can get the following proposition:


\begin{proposition}[No to be super schema of one schema]\label{pro:subofCMXS}
Given a schema $s_{1}$, a test case $t$, where $s_{1} \preceq t$, we have \{$s\ |\ s \preceq t\ \&\&\ s_{1} \npreceq s$\} $=$  \{$ s\ |\ \exists s_{1}' \in CMXS(s_{1}, t)$, $s \preceq s_{1}'$\}.
\end{proposition}

\begin{proof}

Let A =  \{$s\ |\ s \preceq t\ \&\&\ s_{1} \npreceq s$\}, and B = \{$ s\ |\ \exists s_{1}' \in CMXS(s_{1}, t)$, $s \preceq s_{1}'$\}.



Let $s_{1}$ = \{$(p_{x_{1}}, v_{x_{1}})$, $(p_{x_{2}}, v_{x_{2}})$, ..., $(p_{x_{k}}, v_{x_{k}})$\},  t = \{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, ..., $(p_{n}, v_{n})$\}, and CMXS($s_{1}$,$t$)= \{$t \backslash (p_{x_{i}}, v_{x_{i}})$ | $(p_{x_{i}},$ $v_{x_{i}})$ $ \in s_{1} $\}.

First we will show A $\subseteq$ B.

With respect to set A, $\forall s' \in A$, it has $s' \preceq t$ and $ s_{1} \npreceq s'$. That is, $\forall e \in s', e \in t$, and  $\exists e' \in s_{1}, e' \not\in s'$. As $s_{1} \preceq t$, $e' \in t$. Hence, we have $\forall e \in s', e \in t \backslash e'$, i.e., $s' \preceq t \backslash e'$.

Since $t \backslash e' \in CMXS(s_{1}, t)$,  $s' \in $ \{$ s\ |\ \exists s_{1}' \in CMXS(s_{1}, t)$, $s \preceq s_{1}'$\} = B. Hence, A $\subseteq$ B.

Second we will show B $\subseteq$ A.

With respect to set B, $\forall s' \in B$, it has $\exists s_{1}' \in CMXS(s_{1}, t), s'$ $ \preceq s_{1}'$. Since $s_{1}' \in CMXS(s_{1}, t)$, $\exists e' \in s_{1}, s_{1}' =  t \backslash e'$. Consequently, $s' \preceq t \backslash e'$. Hence, $s_{1} \npreceq s'$. Also, $s' \preceq t \backslash e' \prec t$. Consequently, $s \in $  \{$s\ |\ s \prec t\ \&\&\ s_{1} \npreceq s$\} = A, which indicates that B $\subseteq$ A.

As we have shown B $\subseteq$ A, and A $\subseteq$ B, so A = B.

\end{proof}

%This proposition indicates for one specific schema $s$ and test case $t$, the schemas in one test case that are not $s$ and per-schemas of one specific schema, it must be the sub-schema or equal to the schemas in CMXS.

In the equation of Proposition \ref{pro:subofCMXS}, the schemas of the left side, i.e., \{$s\ |\ s \preceq t\ \&\&\ s_{1} \npreceq s$\}, are the sub-schemas of test case $t$, but not the super-schemas of  schema $s_{1}$.  The right side set in this equation, i.e., \{$ s\ |\ \exists s_{1}' \in CMXS(s_{1}, t)$, $s \preceq s_{1}'$\}, are schemas which are sub-schemas of at least one schema in $CMXS(s_{1}, t)$. Proposition \ref{pro:subofCMXS} indicates that these two schema sets are equivalent. As an example, considering a test case $t$ -- \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}, and a schema $s_{f}$ --  \{($p_{3}$, 1)\}. Table \ref{examleOfCMXSPro} shows the schema set  \{$s\ |\ s \prec t\ \&\&\ s_{f} \npreceq s$\}, $CMXS(s_{f}, t)$ and \{$ s\ |\ \exists s_{1}' \in CMXS(s_{f}, t)$, $s \preceq s_{1}'$\}.

% Table generated by Excel2LaTeX from sheet 'Sheet3'
\begin{table*}[ht]
  \centering
  \setlength{\tabcolsep}{2pt}
  \caption{An example of Proposition \ref{pro:subofCMXS}}
  {\footnotesize
    \begin{tabular}{|c|c|c|c|}
    \hline
  \textbf{  Test case $\textbf{t}$} & \textbf{ \{$\textbf{s}\ |\ \textbf{s} \prec \textbf{t}\ \&\&\ \textbf{s}_{\textbf{f}} \npreceq \textbf{s}$\} }& \textbf{ CMXS($\textbf{s}_{\textbf{f}}, $\textbf{t}$ $)} & \textbf{\{$ \textbf{s}\ |\ \exists \textbf{s}_{\textbf{1}}' \in \textbf{CMXS}\textbf{(}\textbf{s}_{\textbf{f}}, \textbf{t}\textbf{)}$, $\textbf{s} \preceq \textbf{s}_{\textbf{1}}'$ \}}\\\hline
    \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}  & \{($p_{1}$, 1),($p_{2}$, 1),($p_{4}$, 1)\} & \{($p_{1}$, 1),($p_{2}$, 1),($p_{4}$, 1)\} & \{($p_{1}$, 1),($p_{2}$, 1),($p_{4}$, 1)\}\\ \cline{1-1}
      \textbf{Schema $\textbf{s}_{\textbf{f}}$}  & \{($p_{1}$, 1),($p_{2}$, 1)\} &  & \{($p_{1}$, 1),($p_{2}$, 1)\} \\\cline{1-1}
     \{($p_{3}$, 1)\}         & \{($p_{1}$, 1),($p_{4}$, 1)\}&  &\{($p_{1}$, 1),($p_{4}$, 1)\}\\
          &       \{($p_{2}$, 1),($p_{4}$, 1)\} &  &\{($p_{2}$, 1), ($p_{4}$, 1)\}\\
          &       \{($p_{1}$, 1)\} &  &\{($p_{1}$, 1)\}\\
          &       \{($p_{2}$, 1)\} &  &\{($p_{2}$, 1)\}\\
          &       \{($p_{4}$, 1)\} &  & \{($p_{4}$, 1)\}\\\hline
    \end{tabular}}%
  \label{examleOfCMXSPro}%
\end{table*}%

%
%We can find that all these schemas can be find at least one. And all the subschemas of the right side are all in the left side. For example, (12) are all the sub-schemas

%when given a faulty schema $c_{1}$ and a failing test case $t$, the pending schemas can only appeared in set \{$c\ |\ \exists c_{1}' \in CMXS(c_{1}, t), c \preceq c_{1}'$\}.

We can extend this conclusion to a set of schemas. For this, we need the following notation: For two schemas $s_{1}$, $s_{2}$, and a test case $t$ ($s_{1} \preceq t$ and $s_{2} \preceq t$), let $CMXS(s_{1}, t) \bigwedge CMXS(s_{2}, t)  = \{ s\ |\ s = s_{1}' \cap s_{2}',\ where\ s_{1}' \in CMXS(s_{1}, t),\ and\ s_{2}' \in CMXS(s_{2}, t) \}$.

For example, let $t$ = \{$(p_{1},v_{1}), (p_{2}, v_{2}), (p_{3}, v_{3})$\}, $s_{1}$ = \{$(p_{1}$ $, v_{1}), (p_{2}, v_{2})$\}, $c_{2}$ = \{$(p_{2}, v_{2}), (p_{3}, v_{3})$\}. Then we have $CMXS$ $(s_{1}, t)$ = \{ \{$(p_{1}, v_{1}), (p_{3}, v_{3})$\}, \{$(p_{2}, v_{2}), (p_{3}, v_{3})$\} \}, $CMXS(s_{2},$ $ t)$ = \{ \{$(p_{1}, v_{1}), (p_{2}, v_{2})$\}, \{$(p_{1}, v_{1}), (p_{3}, v_{3})$\} \}, and  $CMXS(s_{1},$ $ t) \bigwedge CMXS(s_{2}, t) = \{ \{(p_{1}, v_{1})\},$ $ \{(p_{1}, v_{1}), $ $(p_{3}, v_{3})\}, $ $ \{(p_{2}, v_{2})\}, $ $\{(p_{3}, v_{3})\} \} $. It is easy to know the complexity of obtaining $CMXS$ of two schemas is O($\tau^{2}$), where $\tau$ is the number of parameter values in the faulty schema. Based on this, we denote $CMXS(FSS,t)$ for a set of schemas.

\begin{definition}
Given a test case $t$ = \{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, ..., $(p_{n}, v_{n})$\}, and a set of schemas $FSS$ = \{$s_{1} , s_{2}, ... s_{i}, ...$\}, where $ s_{i} \preceq t$,  we denote the candidate maximal non-super schemas of this set as $CMXS(FSS,t)$= $\bigwedge_{s_{i}\in FSS} CMXS(s_{i}, t)$.
\end{definition}

Note to compute the $CMXS$ of a set of schema, we just need to sequentially compute the $CMXS$ of two faulty schemas until the last schema in this set is computed. Hence, the complexity of obtaining $CMXS$ of a set of schemas is O($\tau^{|FSS|}$), where $|FSS|$ is the number of schemas in the schema set, and $\tau$ is the degree of the schema. According to Proposition \ref{pro:subofCMXS}, we have:

\begin{proposition}[No to be super schema of a set of schemas]\label{pro:subofCMXSfor2}
Given a test case t = \{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, ..., $(p_{n}, v_{n})$\}, and a set of schemas FSS = \{$s_{1} , s_{2}, ... s_{i}, ...$\}, where $ s_{i} \preceq t$,  we have \{$s\ |\ s \preceq t\ \&\&\ \forall s_{i} \in FSS, s_{i} \npreceq s $\} $=$  \{$ s\ |\ \exists s_{1}' \in CMXS(FSS, t)$, $s \preceq s_{1}'$\}.
\end{proposition}

\begin{proof}

We just need to prove that for two schemas $s_{1}$, $s_{2}$, and a test case $t$ ($s_{1} \preceq t$, $s_{2} \preceq t$), we have \{$s\ |\ s \prec t\ \&\&\ \forall s_{i} \in \{s_{1}, s_{2}\}, s_{i} \npreceq s $\} $=$  \{$ s\ |\ \exists s_{1}' \in CMXS(s_{1}, t)$ $\bigwedge CMXS(s_{2}, t)$, $s \preceq s_{1}'$\}.

Let $A = $ \{$s\ |\ s \prec t\ \&\&\ \forall s_{i} \in \{s_{1}, s_{2}\}, s_{i} \npreceq s $\}, $A_{1}$ = \{$s\ |\ s \prec t\ \&\&\  s_{1} \npreceq s $\}, $A_{2}$ = \{$s\ |\ s \prec t\ \&\&\  s_{2} \npreceq s $\}. It is easily to get $A = A_{1} \bigcap A_{2}$.

Let $B = $ \{$ s\ |\ \exists s_{1}' \in CMXS(s_{1}, t)$ $\bigwedge CMXS(s_{2}, t)$, $s \preceq s_{1}'$\}. Here,  $ CMXS(s_{1}, t) \bigwedge CMXS(s_{2}, t) = \{ s\ |\ s = s_{1}' \cap s_{2}',\ where\ s_{1}' \in CMXS(s_{1}, t),\ and\ s_{2}' \in CMXS(s_{2}, t) \}$.

Let $B_{1} = $ \{$ s\ |\ \exists s_{1}' \in CMXS(s_{1}, t)$, $s \preceq s_{1}'$\}, and $B_{2} = $ \{$ s\ |\ \exists s_{2}' \in CMXS(s_{2}, t)$, $s \preceq s_{2}'$\}. $B_{1} \bigcap B_{2} = $ \{$ s\ |\ \exists s_{1}' \in CMXS(s_{1}, t)$, $s \preceq s_{1}'$ \&\& $\exists s_{2}' \in CMXS(s_{2}, t)$, $s \preceq s_{2}'$\}. Note that, $s \preceq s_{1}'$ \&\& $s \preceq s_{2}'$ $\equiv$ $s \preceq s_{1}' \cap s_{2}'$. Hence, $B_{1} \bigcap B_{2} = $ \{$ s\ |\ \exists s_{1}', s_{2}',\  s_{1}' \in CMXS(s_{1}, t)$, and $s_{2}' \in CMXS(s_{2}, t)$, $s \preceq s_{1}' \cap s_{2}'$ \} = B.

Based on Proposition \ref{pro:subofCMXS}, $A_{1} = B_{1}$, $A_{2} = B_{2}$. Consequently,
$A = A_{1} \bigcap A_{2}$ = $B_{1} \bigcap B_{2}$  = B.

\end{proof}

Proposition \ref{pro:subofCMXSfor2} extends Proposition \ref{pro:subofCMXS} from a single schema to a set of schemas.

As an example, considering a test case $t$ -- \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}, and a set of schemas  $FSS$ -- \{ \{($p_{3}$, 1)\},  \{($p_{1}$, 1), ($p_{2}$, 1)\} \}. Table \ref{examleOfCMXSPro2} shows the schema set \{$s\ |\ s \preceq t\ \&\&\ \forall s_{i} \in FSS, s_{i} \npreceq s $\}, $CMXS(FSS, t)$ and \{$ s\ |\ \exists s_{1}' \in CMXS(FSS, t)$, $s \preceq s_{1}'$\}.

% Table generated by Excel2LaTeX from sheet 'Sheet3'

\begin{table*}[ht]
  \centering
  \setlength{\tabcolsep}{2pt}
  \caption{An example of Proposition \ref{pro:subofCMXSfor2}}
  {\footnotesize
    \begin{tabular}{|c|c|c|c|}
    \hline
  \textbf{  Test case $\textbf{t}$} & \textbf{ \{$\textbf{s}\ |\ \textbf{s} \preceq \textbf{t}\ \&\&\ \forall \textbf{s}_{\textbf{i}} \in FSS, \textbf{s}_{\textbf{i}} \npreceq \textbf{s}$\} }& \textbf{  CMXS(FSS, t)} & \textbf{\{$ \textbf{s}\ |\ \exists \textbf{s}_{\textbf{1}}' \in \textbf{ CMXS(FSS, t)} $ , $\textbf{s} \preceq \textbf{s}_{\textbf{1}}'$ \}}\\\hline
    \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}  & \{($p_{1}$, 1),($p_{4}$, 1)\} & \{($p_{1}$, 1),($p_{4}$, 1)\} & \{($p_{1}$, 1),($p_{4}$, 1)\}\\ \cline{1-1}
      \textbf{Schema set FSS}  & \{($p_{2}$, 1),($p_{4}$, 1)\} &  \{($p_{2}$, 1),($p_{4}$, 1)\} & \{($p_{2}$, 1),($p_{4}$, 1)\} \\\cline{1-1}
     \{($p_{3}$, 1)\}         & \{($p_{1}$, 1)\}&  &\{($p_{1}$, 1)\}\\
     \{($p_{1}$, 1),($p_{2}$, 1)\}  &       \{($p_{2}$, 1)\} &  &\{($p_{2}$, 1)\}\\
          &       \{($p_{4}$, 1)\} &  & \{($p_{4}$, 1)\}\\\hline
    \end{tabular}}%
  \label{examleOfCMXSPro2}%
\end{table*}%
%
%\begin{proof}
%
%\end{proof}
%Based on previous propositions, we can get that the pending schemas can only appeared in set $P_{up}$ = \{$c\ |\ \exists c_{1}' \in CMXS(FSS,t), c \preceq c_{1}'$\}.


Next, we give the definition of $CMNS$.

\begin{definition}
For a $k$-degree schema $s$ = \{$(p_{x_{1}}, v_{x_{1}})$, $(p_{x_{2}}, v_{x_{2}})$, ..., $(p_{x_{k}}, v_{x_{k}})$\}, a test case $t$ = \{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, ..., $(p_{n}, v_{n})$\}, and $s \preceq t$. We denote the candidate minimal non-sub schema set as $CMNS(s,t)$=\{$\{(p_{x_{i}}, v_{x_{i}})\}$ | $(p_{x_{i}}, v_{x_{i}}) \in t \backslash s $\}.
\end{definition}

Note that $CMNS$ is the set of schemas that are assigned to one distinct factor value that is not in $s$, such that all these schemas will not be the sub-schema of $s$. For example assume the test case \{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, $(p_{3}, v_{3})$, $(p_{4}, v_{4})$\}, and a schema \{$(p_{1}, v_{1})$, $(p_{3}, v_{3})$\}. Then the $CMNS$ set is \{ \{$(p_{2}, v_{2})$\}, \{$(p_{4}, v_{4})$\} \}.  With respect to the CMNS set of a single schema, we can get the following proposition:

\begin{proposition}[Not to be subschema of one schema]\label{pro:superofCMNS}
Given a schema $s_{1}$, a test case $t$, where $s_{1} \preceq t$, we have \{$s\ |\ s \preceq t\ \&\&\ s \npreceq s_{1}$\} $=$  \{$ s\ |\ s \preceq t \  \&\& \ \exists s_{1}' \in CMNS(s_{1}, t)$, $s_{1}' \preceq s$\}.
\end{proposition}

\begin{proof}
Let A = \{$s\ |\ s \preceq t\ \&\&\ s \npreceq s_{1}$\}. B = \{$ s\ |\ s \preceq t \ \&\&\  \exists s_{1}' \in CMNS(s_{1}, t)$, $s_{1}' \preceq s$\}. $CMNS(s_{1},t)$=\{$(p_{x_{i}}, v_{x_{i}})$ | $(p_{x_{i}}, v_{x_{i}}) \in t \backslash s_{1} $\}.

First we will show A $\subseteq$ B.

With respect to set A, $\forall s' \in A$, it has $s' \preceq t$ and $s' \npreceq s_{1}$. That is, $\forall e \in s', e \in t$, and  $\exists e' \in s', e' \not\in s_{1}$. Hence, $\{e'\}\ \preceq s',\  e' \in t \backslash s_{1}$, which indicates that $s' \in $ \{$ s\ |\ s \preceq t \ \&\&\  \exists s_{1}' \in CMNS(s_{1}, t)$, $s_{1}' \preceq s$\} = B. So, A $\subseteq$ B.


Second we will show B $\subseteq$ A.

With respect to set B, $\forall s' \in B$, it has $s' \preceq t$  and $\exists s_{1}' \in CMNS(s_{1}, t), s_{1}' \preceq s'$. As $s_{1}' \in CMNS(s_{1}, t)$, $\exists e' \in  t \backslash s_{1}, s_{1}' = \{ e' \}$. Hence, $\{e'\} \preceq s'$. Hence, $s' \npreceq s_{1}$. Consequently, $s' \in $  \{$s\ |\ s \preceq t\ \&\&\ s \npreceq s_{1}$\} = A, which indicates that B $\subseteq$ A.

\end{proof}


%This proposition means that the pending schema must be the super-schema or equal to the schemas in CMNS, otherwise, it is a healthy schema.

In the equation of Proposition \ref{pro:superofCMNS}, the schemas of the left side, i.e., \{$s\ |\ s \preceq t\ \&\&\ s \npreceq s_{1}$\}, are the sub-schemas of test case $t$, but not the sub-schemas of schema $s_{1}$. The right side set in this equation, i.e.,\{$ s\ |\ s \preceq t \  \&\& \ \exists s_{1}' \in CMNS(s_{1}, t)$, $s_{1}' \preceq s$\}, are sub-schemas of test case $t$, and also are the super-schemas of at least one schema in $CMNS(s_{1}, t)$. Proposition \ref{pro:superofCMNS} indicates that these two schema sets are equivalent. As an example, considering a test case $t$ -- \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}, and a schema $c_{h}$ --  \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1)\}. Table \ref{examleOfCMNSPro} shows the schema set  \{$s\ |\ s \preceq t\ \&\&\ s_{h} \npreceq s$\}, $CMNS(s_{h}, t)$ and {$ s\ |\ s \preceq t\ \&\& \ \exists s_{1}' \in CMNS(s_{h}, t)$, $s_{1}' \preceq s$\}.

% Table generated by Excel2LaTeX from sheet 'Sheet3'
\begin{table*}[ht]
  \centering
  \setlength{\tabcolsep}{2pt}
  \caption{An example of Proposition \ref{pro:superofCMNS}}
  {\footnotesize
    \begin{tabular}{|c|c|c|c|}
    \hline
  \textbf{  Test case $\textbf{t}$} & \textbf{ \{$\textbf{s}\ |\ \textbf{s} \preceq \textbf{t}\ \&\&\ \textbf{s} \npreceq \textbf{s}_{\textbf{h}}$\} }& \textbf{ CMNS($\textbf{s}_{\textbf{h}}$, $\textbf{t}$)} & \textbf{\{$ \textbf{s}\ |\ \textbf{s} \preceq \textbf{t} \ \&\& \ \exists \textbf{s}_{\textbf{1}}' \in \textbf{CMNS}\textbf{(}\textbf{s}_{\textbf{h}}, \textbf{t}\textbf{)}$, $  \textbf{s}_{\textbf{1}}' \preceq \textbf{s}$ \}}\\\hline
    \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}  & \{($p_{4}$, 1)\} & \{($p_{4}$, 1)\} & \{(($p_{4}$, 1)\}\\ \cline{1-1}
      \textbf{Schema $\textbf{s}_{\textbf{h}}$}  & \{($p_{1}$, 1),($p_{4}$, 1)\} &  & \{($p_{1}$, 1),($p_{4}$, 1)\} \\\cline{1-1}
     \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1)\}         &\{($p_{2}$, 1),($p_{4}$, 1)\}  &  & \{($p_{2}$, 1),($p_{4}$, 1)\}  \\
                         &\{$p_{3}$, 1),($p_{4}$, 1)\}   &  & \{$p_{3}$, 1),($p_{4}$, 1)\}  \\
                         &\{($p_{1}$, 1),($p_{2}$, 1),($p_{4}$, 1)\}   &  & \{($p_{1}$, 1),($p_{2}$, 1),($p_{4}$, 1)\}  \\
                         &\{($p_{1}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}  &  & \{($p_{1}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}  \\
                         &\{($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}  &  & \{($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}  \\ \hline
    \end{tabular}}%
  \label{examleOfCMNSPro}%
\end{table*}%


Similarly, for two healthy schemas $s_{1}$, $s_{2}$, and a test case $t$ ($s_{1} \preceq t$, $s_{2} \preceq t$), let $CMNS(s_{1}, t) \bigvee $ $CMNS(s_{2}, t)  = \{ s\ |\ s = s_{1}' \cup s_{2}',\ where\ s_{1}' \in CMNS(s_{1}, t),\ and\ s_{2}' \in CMNS(s_{2}, t) \}$.

For example, let $t$ = \{$(p_{1},v_{1}), (p_{2}, v_{2}), (p_{3}, v_{3})$\}, $s_{1}$ = \{$(p_{1}$ $, v_{1}), (p_{2}, v_{2})$\}, $s_{2}$ = \{$(p_{2}, v_{2}), (p_{3}, v_{3})$\}. Then we have $CMNS$ $(s_{1}, t)$ = \{ \{$(p_{3}, v_{3})$\} \}, $CMNS(s_{2},$ $ t)$ = \{ \{$(p_{1}, v_{1})$\} \}, and  $CMNS(s_{1},$ $ t) \bigvee CMNS(s_{2}, t) = \{ \{(p_{1}, v_{1}), (p_{3}, v_{3})\} \} $. Based on this, we denote $CMNS(HSS,t)$ for a set of faulty schemas.


\begin{definition}
Given a test case $t$ = \{$(p_{1}, v_{1})$, $(p_{2}, $ $v_{2})$, ..., $(p_{n}, v_{n})$\}, and a set of schemas $HSS$ = \{$s_{1} , s_{2},$ $  ...s_{i}, ...$\}, where $ s_{i} \preceq t$, we denote the candidate minimal non-sub schema of this set as $CMNS(HSS,t)$=  $\bigvee_{s_{i}\in HSS}$ $ CMNS(s_{i}, t)$.
\end{definition}

Similar to $CMXS(FSS,t)$, the complexity to obtain $CMNS(HSS,t)$ is O($\tau^{|HSS|}$), where $|HSS|$ is the number of schemas in the schema set, and $\tau$ is the degree of the schema. With respect to $CMNS(HSS,t)$, we have:

\begin{proposition}[Not to be subschema of a set of schemas]\label{pro:superofCMNS2}
Given a test case t = \{$(p_{1}, v_{1})$, $(p_{2}, v_{2})$, ..., $(p_{n}, v_{n})$\}, and a set of schemas $HSS$ = \{$s_{1} , s_{2}, ... s_{i}, ...$\}, where $s_{i} \preceq t$,  we have \{$s\ |\ s \preceq t\ \&\&\ \forall s_{i} \in HSS, s \npreceq s_{i} $\} $=$  \{$ s\ |\ s \preceq t \ \&\& \ \exists s_{1}' \in CMNS(HSS, t)$, $s_{1}' \preceq s$\}.
\end{proposition}

\begin{proof}
We just need to prove that for two schemas $s_{1}$, $s_{2}$, and a test case $t$ ($s_{1} \preceq t$, $s_{2} \preceq t$), we have \{$s\ |\ s \preceq t\ \&\&\ \forall s_{i} \in \{s_{1}, s_{2}\}, s \npreceq s_{i} $\} $=$  \{$ s\ |\ s \preceq t \ \&\&\  \exists s_{1}' \in CMNS(s_{1}, t)$ $ \bigvee CMNS(s_{2}, t)$, $s_{1}' \preceq s$\}.

Let $A = $ \{$s\ |\ s \preceq t\ \&\&\ \forall s_{i} \in \{s_{1}, s_{2}\}, s \npreceq s_{i} $\}, $A_{1}$ = \{$s\ |\ s \preceq t\ \&\&\  s \npreceq s_{1} $\}, $A_{2}$ = \{$s\ |\ s \preceq t\ \&\&\  s \npreceq s_{2} $\}. It is easily to get $A = A_{1} \bigcap A_{2}$.

Let $B = $ \{$ s\ |\ s \preceq t \ \&\&\  \exists s_{1}' \in CMNS(s_{1}, t)$ $ \bigvee CMNS(s_{2}, t)$, $s \preceq s_{1}'$\}. Here,    $ CMNS(s_{1}, t) \bigvee CMNS(s_{2}, t) = \{ s\ |\ s = s_{1}' \cup s_{2}',\ where\ s_{1}' \in CMNS(s_{1}, t),\ and\ s_{2}' \in CMNS(c_{2}, t) \}$.

Let $B_{1} = $ \{$ s\ |\ s \preceq t \ \&\&\  \exists s_{1}' \in CMNS(s_{1}, t)$, $s_{1}' \preceq s$\}, and $B_{2} = $ \{$ s\ |\ s \preceq t \ \&\&\  \exists s_{2}' \in CMNS(s_{2}, t)$, $s_{2}' \preceq s$\}. $B_{1} \bigcap B_{2} = $ \{$ s\ |\ s \preceq t \ \&\&\  \exists s_{1}' \in CMNS(s_{1}, t)$, $s_{1}' \preceq s$ \&\& $\exists s_{2}' \in CMNS(s_{2}, t)$, $s_{2}' \preceq s$\}. Note that, $s_{1}' \preceq s $ \&\& $s_{2}' \preceq s$ $\equiv$ $s_{1}' \cup s_{2}' \preceq s$. Hence, $B_{1} \bigcap B_{2} = $ \{$ s\ |\ s \preceq t \ \&\&\  \exists s_{1}', s_{2}',\  s_{1}' \in CMNS(s_{1}, t)$, and $s_{2}' \in CMNS(s_{2}, t)$, $ s_{1}' \cup s_{2}' \preceq s$ \} = B.

Based on Proposition \ref{pro:superofCMNS}, $A_{1} = B_{1}$, $A_{2} = B_{2}$. Consequently,
$A = A_{1} \bigcap A_{2}$ = $B_{1} \bigcap B_{2}$  = B.


\end{proof}

Similar to Proposition \ref{pro:subofCMXS} and \ref{pro:subofCMXSfor2},  Proposition \ref{pro:superofCMNS2} extends Proposition \ref{pro:superofCMNS} from a single  schema to a set of schemas.

As an example, considering a test case $t$ -- \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}, and a set of schemas  $HSS$ -- \{ \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1)\},  \{($p_{3}$, 1),($p_{4}$, 1)\} \}. Table \ref{examleOfCMNSPro2} shows the schema set \{$s\ |\ s \preceq t\ \&\&\ \forall s_{i} \in HSS, s \npreceq s_{i} $\}, $CMNS(HSS, t)$ and \{$ s\ |\ s \preceq t \ \&\& \ \exists s_{1}' \in CMNS(HSS, t)$, $s_{1}' \preceq s$\}.

% Table generated by Excel2LaTeX from sheet 'Sheet3'

\begin{table*}[ht]
  \centering
  \setlength{\tabcolsep}{1pt}
  \caption{An example of Proposition \ref{pro:superofCMNS2}}
  {\footnotesize
    \begin{tabular}{|c|c|c|c|}
    \hline
  \textbf{  Test case $\textbf{t}$} & \textbf{ \{$\textbf{s}\ |\ \textbf{s} \preceq \textbf{t}\ \&\&\ \forall \textbf{s}_{\textbf{i}} \in \textbf{HSS}, \textbf{s} \npreceq \textbf{s}_{\textbf{i}} $\} }& \textbf{  CMNS(HSS, t)} & \textbf{\{$ \textbf{s}\ |\ \textbf{s} \preceq \textbf{t} \ \&\& \ \exists \textbf{s}_{\textbf{1}}' \in \textbf{CMNS(HSS, t)}$, $\textbf{s}_{\textbf{1}}' \preceq \textbf{s}$\}}\\\hline
    \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}  & \{($p_{1}$, 1),($p_{4}$, 1)\} & \{($p_{1}$, 1),($p_{4}$, 1)\} & \{($p_{1}$, 1),($p_{4}$, 1)\}\\ \cline{1-1}
      \textbf{Schema set HSS}  & \{($p_{2}$, 1),($p_{4}$, 1)\} & \{($p_{2}$, 1),($p_{4}$, 1)\} & \{($p_{2}$, 1),($p_{4}$, 1)\} \\\cline{1-1}
     \{($p_{1}$, 1),($p_{2}$, 1),($p_{3}$, 1)\}         &\{($p_{1}$, 1),($p_{2}$, 1),($p_{4}$, 1)\}  &  &  \{($p_{1}$, 1),$p_{2}$, 1),($p_{4}$, 1)\}   \\
     \{($p_{3}$, 1),($p_{4}$, 1)\}         &\{($p_{1}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}    &  &  \{($p_{1}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}  \\
                         &\{($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}   &  & \{($p_{2}$, 1),($p_{3}$, 1),($p_{4}$, 1)\}   \\ \hline
    \end{tabular}}%
  \label{examleOfCMNSPro2}%
\end{table*}%


Based on Proposition \ref{pro:subofCMXSfor2} and \ref{pro:superofCMNS2}, we can easily learn that \{$s\ |\ s \preceq t\ \&\&\ \forall s_{i} \in FSS, s_{i} \npreceq s $\} $\bigcap$ \{$s\ |\ s \preceq t\ \&\&\ \forall s_{i} \in HSS, s \npreceq s_{i} $\}  $=$  \{$ s\ |\ \exists s_{1}' \in CMXS(FSS, t)$, $s \preceq s_{1}'$\} $\bigcap$  \{$ s\ |\ s \preceq t \ \&\& \ \exists s_{1}' \in CMNS(HSS, t)$, $s_{1}' \preceq s$\}.  Considering $\forall s \in $\{$ s\ |\ \exists s_{1}' \in CMXS(FSS, t)$, $s \preceq s_{1}'$\}, $s \preceq t$, we have  \{$ s\ |\ \exists s_{1}' \in CMXS(FSS, t)$, $s \preceq s_{1}'$\} $\bigcap$  \{$ s\ |\ s \preceq t \ \&\& \ \exists s_{1}' \in CMNS(HSS, t)$, $s_{1}' \preceq s$\} =  \{$ s\ |\ \exists s_{1}' \in CMXS(FSS, t)$, $s \preceq s_{1}'$\} $\bigcap$  \{$ s\ | \exists s_{1}' \in CMNS(HSS, t)$, $s_{1}' \preceq s$\}.

Let $t$ be the failing test case, the schemas set $PTS^{t\bigtriangleup}$ be the set of schemas $HSS$ (it satisfies that $\forall s \in PTS^{t\bigtriangleup}, s \preceq t $), the minimal faulty schemas $MFSS^{t}$ be the set of schemas $FSS$ (it also satisfies that $\forall s \in MFSS^{t}, s \preceq t $). Then we transform the aforementioned formula (Formula \ref{eq:pssfirst}) to be the following equation.

\{$s\ |\ s \preceq t\ \&\&\ \forall t_{i} \in PTS^{t\bigtriangleup}, s \npreceq t_{i} \&\&\ \forall m \in MFSS^{t}, m \npreceq s   $\} $=$  \{$ s\ |\ $ $\exists s_{1}' \in CMNS(PTS^{t\bigtriangleup}, t)$, $s_{1}' \preceq s$  $\&\&$ $\exists s_{1}' \in CMXS(MFSS^{t}, t)$, $s \preceq s_{1}'$  \} $=$  \{$ s\ |\ \exists s_{1}' \in CMNS(PTS^{t\bigtriangleup}, t), s_{2}' \in CMXS(MFSS^{t}, t)$, $s_{1}' \preceq s \preceq s_{2}'$ \}.

At last, we can learn that the pending schemas set is equal to the following formula.

%\begin{equation}\label{eq:psssecond}
%\begin{aligned}
%PSS = & \{ c\ |\ \exists c_{1}' \in CMXS(FSS, t), c \preceq c_{1}' \\
%    & \&\& \exists c_{1}' \in CMNS(HSS, t), c_{1}' \preceq c\}.
%\end{aligned}
%%PSS = \{ c\ |\ \exists c_{1}' \in CMNS(HSS, t), c_{1}' \preceq c \&\& \exists c_{1}' \in CMNS(HSS, t), c_{1}' \preceq c\}.
%\end{equation}

%Further

\begin{equation}\label{eq:psssecond}
\begin{aligned}
PSS =  \{ s\ |\ \exists s_{1}' \in CMNS(PTS^{t\bigtriangleup}, t), s_{2}' \in CMXS(MFSS^{t}, t),  s_{1}' \preceq s \preceq s_{2}' \}.
\end{aligned}
%PSS = \{ c\ |\ \exists c_{1}' \in CMNS(HSS, t), c_{1}' \preceq c \&\& \exists c_{1}' \in CMNS(HSS, t), c_{1}' \preceq c\}.
\end{equation}

According to Formula \ref{eq:psssecond}, the complexity of obtaining one pending schema is O($ \tau^{|MFSS^{t}|} \times \tau^{|PTS^{t\bigtriangleup}|}$). This is because to obtain one pending schema, we only need to search the schemas in $CMXS(MFSS^{t}, t)$ and $CMNS(PTS^{t\bigtriangleup}, t)$, of which the complexity are O($\tau^{|MFSS^{t}|}$) and O($\tau^{|PTS^{t\bigtriangleup}|}$), respectively. Then we need to check each pair of schemas in these two sets, to find whether exists $c_{1} \in CMXS(MFSS^{t}, t)$, $c_{2} \in CMNS(PTS^{t\bigtriangleup}, t)$, such that $c_{2} \preceq c_{1}$. If so, then both $c_{2}$ and $c_{1}$ satisfy Formula \ref{eq:psssecond}. Furthermore, $\forall c_{3}, c_{2} \preceq c_{3} \preceq c_{1}$, $c_{3}$ also satisfy Formula \ref{eq:psssecond}. Hence, the complexity of obtaining one pending schema is O($\tau^{|MFSS^{t}|} \times \tau^{|PTS^{t\bigtriangleup}|}$). Note that with Formula \ref{eq:psssecond}, we have eliminated the influence of the number $n$ (See Formula \ref{eq:pssfirst} and Formula \ref{eq:pssfirst_mutated}) to obtaining the pending schemas.
%In fact, we can further reduce the complexity of obtaining pending schemas. When given a set of schemas $S$, let the minimal schemas as $S^{\bot } = \{ c | c \in S, \nexists c' \in S, c' \prec c \}$ and the maximal schemas as $S^{\top } = \{ c | c \in S, \nexists c' \in S, c \prec c' \}$. Based on this, we can have the following proposition:
%
%\begin{proposition}\label{pro:identicialPending}
%Given a failing test case $t$, a set of faulty schemas $FSS$, and a set of healthy schemas $HSS$, we have \{$ c\ |\ \exists c_{1}' \in CMXS(FSS^{\bot}, t)$, $ c_{2}' \in CMNS($ $HSS^{\top}, t)$, $c_{2}' \preceq c \preceq c_{1}'$ \} $=$  \{$ c\ |\ \exists c_{1}' \in CMXS(FSS, t)$, $c_{1}' \in CMNS(HSS, t)$, $c_{2}' \preceq c \preceq c_{1}'$ \}.
%\end{proposition}
%
%\begin{proof}
%Let A = \{$ c\ |\ \exists c_{1}' \in CMXS(FSS^{\bot}, t)$, $c_{2}' \in $ $CMNS$ $(HSS^{\top}, t)$, $c_{2}' \preceq c \preceq c_{1}'$\}.
%
%
%Let B =  \{$ c\ |\ \exists c_{1}' \in CMXS(FSS, t)$, $c_{2}' \in CMNS($ $HSS, t)$, $c_{2}' \preceq c \preceq c_{1}'$ \}.
%
%
%Based on Proposition \ref{pro:subofCMXSfor2} and \ref{pro:superofCMNS2}:
%
%A = \{$c\ |\ c \prec t\ \&\&\ \forall c_{i} \in FSS^{\bot}, c _{i} \npreceq c \ \&\&\  \forall c_{i} \in HSS^{\top}, c \npreceq c_{i}  $\}.
%
%B = \{$c\ |\ c \prec t\ \&\&\ \forall c_{i} \in FSS, c _{i} \npreceq c \ \&\&\  \forall c_{i} \in HSS, c \npreceq c_{i}  $\}.
%
%
%First we will prove B $\subseteq$ A.
%
%As $FSS^{\bot} \subseteq FSS,\ HSS^{\top} \subseteq HSS$, \{ $c\ |\ \forall c_{i} \in FSS, c_{i} \npreceq c $\}  $\subseteq$  \{ $c\ |\ \forall c_{i} \in FSS^{\bot}, c_{i} \npreceq c $\} and \{ $c\ |\ \forall c_{i} \in HSS, c \npreceq c_{i} $\}  $\subseteq$  \{ $c\ |\ \forall c_{i} \in HSS^{\top}, c \npreceq c_{i} $\}. Hence, \{$c\ |\ c \prec t\ \&\&\ \forall c_{i} \in FSS, c _{i} \npreceq c \ \&\&\  \forall c_{i} \in HSS, c \npreceq c_{i}  $\}  $\subseteq$ \{$c\ |\ c \prec t\ \&\&\ \forall c_{i} \in FSS^{\bot}, c _{i} \npreceq c \ \&\&\  \forall c_{i} \in HSS^{\top}, c \npreceq c_{i}  $\}. That is  $B \subseteq A$.
%
%Next we will prove A $\subseteq$ B.
%
%Note that  $\forall c \prec t$, if $\forall c_{i} \in FSS^{\bot}, c_{i} \npreceq c$, it must have $\forall c_{i}' \in FSS, c_{i}' \npreceq c$. Because if not so, then $\exists c_{i}' \in FSS, c_{i}' \preceq c$. As $\exists c_{i} \in FSS^{\bot}, c_{i}' \in FSS, c_{i} \preceq c_{i}'$, hence, $c_{i} \preceq c_{i}' \preceq c$,  which is contradiction.
%
%Similarly, $\forall c \prec t$, if $\forall c_{i} \in HSS^{\top}, c \npreceq c_{i}$, it must have $\forall c_{i}' \in HSS, c \npreceq c_{i}'$. Because if not so, then $\exists c_{i}' \in HSS, c \preceq c_{i}'$. As $\exists c_{i} \in HSS^{\top}, c_{i}' \in HSS, c_{i}' \preceq c_{i}$, hence, $c \preceq c_{i}' \preceq c_{i}$,  which is contradiction.
%
%Combining them, we can get $\forall c' \in $\{$c\ |\ c \prec t\ \&\&\ \forall c_{i} \in FSS^{\bot}, c _{i} \npreceq c \ \&\&\  \forall c_{i} \in HSS^{\top}, c \npreceq c_{i}  $\}, $c' \in $ \{$c\ |\ c \prec t\ \&\&\ \forall c_{i} \in FSS, c _{i} \npreceq c \ \&\&\  \forall c_{i} \in HSS, c \npreceq c_{i}  $\}. That is, A $\subseteq$ B.
%
%As we have shown B $\subseteq$ A, and A $\subseteq$ B, so A = B.
%\end{proof}

As an example, consider a failing test case $t = \{(p_{1}, 1),$ $ (p_{2}, 1), (p_{3}, 1), (p_{4}, 1)\}$, the faulty schema set $FSS =$ \{ $\{(p_{1}, $ $1), (p_{2}, 1), (p_{3}, 1)\}$, $\{(p_{1}, 1), (p_{2}, 1)\}$ \}, and the healthy schema set $HSS =$  \{ $\{(p_{2}, 1),$ $(p_{3}, 1),$ $(p_{4}, 1)\}$, $\{(p_{2}, 1), (p_{3}, 1)\}$ \}. It is easy to learn that the minimal faulty schema set $FSS^{\bot} = \{\{(p_{1}, 1), (p_{2}, 1)\}\}$, and the maximal healthy schema set $HSS^{\top}$ $= \{\{ (p_{2}, 1), (p_{3}, 1), (p_{4}, 1) \}\}$.

Fig \ref{fig_minmax} lists all the faulty schemas, healthy schemas, and pending schemas of test case $t$. At the second part, it lists the $CMXS(FSS, t)$, $CMNS(HSS, t)$, and the schema set \{$ c\ |\ \exists c_{1}' \in CMXS(FSS, t)$, $c_{1}' \in CMNS(HSS, t)$, $c_{2}' \preceq c \preceq c_{1}'$ \}. At last it shows $CMXS(FSS^{\bot}, t)$, $CMNS(HSS^{\top}, t)$ and  \{$ c\ |\ \exists c_{1}' \in CMXS(FSS^{\bot}, t)$, $ c_{2}' \in CMNS($ $HSS^{\top}, t)$, $c_{2}' \preceq c \preceq c_{1}'$ \}.

%We can learn that these two schema set mentioned in Proposition \ref{pro:identicialPending} are identical in Fig \ref{fig_minmax}, but the schema set based on $CMXS(FSS^{\bot}, t)$, $CMNS(HSS^{\top}, t)$ used much fewer schemas (3 in total) to obtain the result than the schema set based on $CMXS(FSS, t)$, $CMNS(HSS, t)$ (7 in total). Another observation from this figure is that these two schema set are both identical to the pending schemas. It suggests that using CMXS and CMNS can effectively and efficiently to get the pending schemas, when compared to list all the schemas in a test case and find the pending schema one by one according to Formula \ref{eq:pssfirst}.

\begin{figure*}[ht]
 \centering
 \includegraphics[width=5.6in]{minmax.eps}
 \caption{The example of Proposition }
 \label{fig_minmax}
\end{figure*}


%At last, according to Proposition \ref{pro:identicialPending}, we have the third formula to compute pending schemas as follow:
%
%\begin{equation}\label{eq:pssthird}
%\begin{aligned}
%PSS =  \{ c\ |\ \exists c_{1}' \in CMXS(FSS^{\bot}, t), c_{2}' \in CMNS(HSS^{\top}, t), c_{2}' \preceq c \preceq c_{1}' \}.
%\end{aligned}
%%PSS = \{ c\ |\ \exists c_{1}' \in CMNS(HSS, t), c_{1}' \preceq c \&\& \exists c_{1}' \in CMNS(HSS, t), c_{1}' \preceq c\}.
%\end{equation}
%
%According to Formula \ref{eq:pssthird}, the complexity of obtaining one pending schema is O($ \tau^{|FSS^{\bot}|} \times \tau^{|HSS^{\top}|}$), where $|FSS^{\bot}|$ and $|HSS^{\top}|$ are two relatively small numbers during MFS identification.

\subsection{A case study of applying Formula }
In this section, we will show a case study of how to obtain the pending schemas with Formula \ref{eq:pssthird}. For consistency, we use the example in the Section \ref{sec:motiv}. Next, we will show how to  apply Formula \ref{eq:pssthird} to obtain the pending schemas of the failing test case $t_{5}$ after using FINOLP. Note that other approaches can be obtained in the same way.
%  in the FINOLP. Others are shown in the appendix in a similar way.
From Figure , we can learn that the maximal healthy schemas are the passing test cases themselves, which are $t_{1}$ ,..., and $t_{16}$. While the minimal faulty schemas are the MFS  (Other faulty schemas are the super schemas of this one).
Then we can learn that.  Note that we can learn that .

%When applying this analysis, we can get back to the motivation example.
%We do not need list all the schemas, but we can figure out which one is the pending schema (Covering array, OFOT, OFOT with single  MFS, FIC, FIC with multiple )


% Start of "Sample References" section

\section{Empirical studies}\label{sec:emp}


\subsection{The pending schemas for covering arrays}

%subjects (30 existing wildly used)
%
%generation approaches (ipog, aetg, augmented simulating?)

\subsection{The existence of pending schemas for different MFS identification approaches}

%subjects (my , may also used from )
%
%approaches (my)

\subsection{Does the exitentce of pending schemas contain some potential MFS which may be harmful}
In fact, this is the motivation


\subsection{The characteristics of pending schemas with various types of MFS (multiple, overlapped, single, low-high degrees)}

%the same as the captions


\subsection{The effectiveness of the approach}

%three way: (three formulas in the propositions)


\subsection{Threats to validity}


\section{Discussion}\label{sec:discussion}


\section{Related works}\label{sec:related}
Shi and Nie \cite{shi2005software} presented an approach for failure revealing and failure diagnosis in CT , which first tests the SUT with a covering array, then reduces the value schemas contained in the failing test case by eliminating those appearing in the passing test cases. If the failure-causing schema is found in the reduced schema set, failure diagnosis is completed with the identification of the specific input values which caused the failure; otherwise, a further test suite based on SOFOT is developed for each failing test case, and the schema set is then further reduced, until no more faults are found or the fault is located. Based on this work, Wang \cite{wang2010adaptive} proposed an AIFL approach which extended the SOFOT process by adaptively mutating factors in the original failing test cases in each iteration to characterize failure-inducing interactions.

Nie et al. \cite{nie2011minimal} introduced the notion of Minimal Failure-causing Schema(MFS) and proposed the OFOT approach which is an extension of SOFOT that can isolate the MFS in the SUT. This approach mutates one value of that parameter at a time, hence generating a group of additional test cases each time to be executed. Compared with SOFOT, this approach  strengthens the validation of the factor under analysis and can also detect the newly imported faulty interactions.

Delta debugging \cite{zeller2002simplifying} is an adaptive divide-and-conquer approach to locate interaction failure. It is very efficient and has been applied to real software environment. Zhang et al. \cite{zhang2011characterizing} also proposed a similar approach that can efficiently identify the failure-inducing interactions that have no overlapped part. Later, Li \cite{li2012improved} improved the delta-debugging based approach by exploiting useful information in the executed covering array.

Colbourn and McClary \cite{colbourn2008locating} proposed a non-adaptive method. Their approach extends a covering array to the locating array to detect and locate interaction failures. Mart{\'\i}nez \cite{martinez2008algorithms,martinez2009locating} proposed two adaptive algorithms. The first one requires safe value as the assumption and the second one removes this assumption when the number of values of each parameter is equal to 2. Their algorithms focus on identifying faulty tuples that have no more than 2 parameters.

Ghandehari et al. \cite{ghandehari2012identifying} defined the suspiciousness of tuple and suspiciousness of the environment of a tuple. Based on this, they ranked the possible tuples and generated the test configurations. They \cite{ghandehari2013fault} further utilized the test cases generated from the inducing interaction to locate the fault.

Yilmaz \cite{yilmaz2006covering} proposed a machine learning method to identify inducing interactions from a combinatorial testing set. They constructed a classification tree to analyze the covering arrays and detect potential faulty interactions. Beside this, Fouch{\'e} \cite{fouche2009incremental} and Shakya \cite{shakya2012isolating} made some improvements in identifying failure-inducing interactions based on Yilmaz's work.

Our previous work \cite{niu2013identifying} proposed an approach that utilizes the tuple relationship tree to isolate the failure-inducing interactions in a failing test case. One novelty of this approach is that it can identify the overlapped faulty interaction. This work also alleviates the problem of introducing new failure-inducing interactions in additional test cases.



\section{Conclusion}\label{sec:conclusion}
To identify the MFS in the SUT is important because it provides additional supports to find the cause of the failure. Although many efforts have been proposed to make the MFS identification approaches more efficient and effective, the existence of pending schemas still make them incomplete, which would be hidden dangers to the software under testing. Hence, to identify these pending schemas is of great importance to reveal such potential risks.

In this paper, we studied the characteristics of the relationships among faulty schemas, healthy schemas, minimal failure-causing schemas, and maximal healthy schemas. The subsuming relationships among them form the basis of the methodology for pending schemas. Particulary, we proposed several propositions to formulate the set of pending schemas and give three equivalent formulas to obtain them. Among the three formulas, the last formula reduce the complexity of obtaining pending schemas from O($2^{n}$) to O($ \tau^{|FSS^{\bot}|+|HSS^{\top}|}$), where $n$ is the number of factors in the software, while $|FSS^{\bot}|$ and $|HSS^{\top}|$ are two relatively small numbers and independent on the number of $n$.

We conduct a series empirical studies on some real software systems with various number of parameters and values. Our results shows that the incompleteness in very common in the covering arrays and MFS identification approaches. We also observed that the third proposed formula is the most efficient when compared others in most cases.

As a future work, it is appealing to take the advantages of the pending schemas to assist in the MFS identification approaches. More specifically, we would like to develop a new framework for MFS identification, which take the pending schemas as a indicator. That is, any MFS identification algorithm that runs on this framework aims to empty the set of pending schemas. It is of interest to evaluate the efficiency and effectiveness of this framework with respect to various MFS identification approaches that run on it.

Another interesting futher work is to obtain a general theory of pending schemas, faulty schemas, and healthy schemas.

% Appendix
\appendix
%\section{Proof}
%
%We will give the proofs of several important propositions.
%
%Proposition \ref{pro:subofCMXS}.
%
%
%Proposition \ref{pro:subofCMXSfor2}.
%
%
%Proposition \ref{pro:superofCMNS}.
%
%%Given a healthy schema $c_{1}$, a failing test case $t$, we have \{$c\ |\ c \preceq t\ \&\&\ c \npreceq c_{1}$\} $=$  \{$ c\ |\ \exists c_{1}' \in CMNS(c_{1}, t)$, $c_{1}' \preceq c$\}.
%
%
%
%Proposition \ref{pro:superofCMNS2}.
%
%
%
%
%Proposition \ref{pro:identicialPending}.
%
%Given a failing test case $t$, a set of faulty schemas $FSS$, and a set of healthy schemas $HSS$, we have \{$ c\ |\ \exists c_{1}' \in CMXS(FSS^{\bot}, t)$, $c \preceq c_{1}'$ $\&\&$ $\exists c_{1}' \in CMNS($ $HSS^{\top}, t)$, $c_{1}' \preceq c$\} $=$  \{$ c\ |\ \exists c_{1}' \in CMXS(FSS, t)$, $c \preceq c_{1}'$ $\&\&$ $\exists c_{1}' \in CMNS(HSS, t)$, $c_{1}' \preceq c$\}.



%\section{Other examples when applied the pending schemas}




\begin{acks}

The authors would like to thank the anonymous reviewers for their hard work and valuable comments. This work was supported by the National Key Research and Development Plan(No. 2018YFB1003800), National Science Foundation Award CNS-1748109, US Department of Homeland Security(DHS-14-ST-062-001), and US National Institute of Standards and Technologies Award(70NANB15H199).


\end{acks}

% Bibliography
\bibliographystyle{ACM-Reference-Format}
\bibliography{sample-bibliography}
